#include "vidicon_configuration.h"

#include "base/strings/string_util.h"
#include "base/strings/stringprintf.h"
#include "base/strings/sys_string_conversions.h"
#include "base/win/scoped_bstr.h"
#include "base/win/scoped_variant.h"
#include "scada/common/analog_item.h"
#include "scada/core/property.h"

#include <opcda.h>

VidiconAddressSpace::VidiconAddressSpace(scada::StandardAddressSpace& std)
    : std(std) {
  AddReference(std.Organizes, std.Objects, DataItems);
}

scada::Node* VidiconAddressSpace::GetNode(const scada::NodeId& node_id) {
  if (node_id == DataItemType.GetId())
    return &DataItemType;
  else if (node_id == DataItems.GetId())
    return &DataItems;
  else
    return nullptr;
}

base::win::ScopedComPtr<IXMLDOMNode> GetParent(IXMLDOMNode& node) {
  base::win::ScopedComPtr<IXMLDOMNode> parent;
  node.get_parentNode(parent.Receive());
  return parent;
}

base::win::ScopedComPtr<IXMLDOMNode> GetNextNode(IXMLDOMNodeList& nodes) {
  base::win::ScopedComPtr<IXMLDOMNode> node;
  nodes.nextNode(node.Receive());
  return node;
}

HRESULT ChangeType(base::win::ScopedVariant& variant, VARTYPE new_type) {
  return ::VariantChangeType(variant.AsInput(), variant.ptr(), 0, new_type);
}

void ExpandAddress(std::wstring& address, IXMLDOMNode& node) {
  base::win::ScopedComPtr<IXMLDOMNode> parent;

  for (base::win::ScopedComPtr<IXMLDOMNode> cur(&node); cur; cur = GetParent(*cur)) {
    auto i = address.find(L'~');
    if (i == std::wstring::npos)
      break;

    base::win::ScopedComPtr<IXMLDOMElement> el;
    if (FAILED(cur.QueryInterface(el.Receive())))
      break;

    static const base::win::ScopedBstr kAddrBase(L"addrBase");
    base::win::ScopedVariant addrBase;
    if (FAILED(el->getAttribute(kAddrBase, addrBase.Receive())) ||
        FAILED(ChangeType(addrBase, VT_BSTR)))
      continue;

    address.replace(i, 1, addrBase.ptr()->bstrVal);
  }
}

const BrowseNodeId kRootBrowseNodeId = 0;

std::pair<bool /*ok*/, BrowseNode> LoadNode(IXMLDOMElement& element) {
  BrowseNode attributes;

  {
    base::win::ScopedBstr name;
    if (FAILED(element.get_nodeName(name.Receive())))
      return {false, {}};
    attributes.folder = base::EqualsASCII(static_cast<BSTR>(name), "Folder");
  }

  // get text attribute
  {
    base::win::ScopedVariant var;
    static base::win::ScopedBstr attrText{L"text"};
    if (FAILED(element.getAttribute(attrText, var.Receive())) ||
        FAILED(ChangeType(var, VT_BSTR)))
      return {false, {}};
    attributes.display_name = var.ptr()->bstrVal;
  }

  // get id_ attribute
  {
    attributes.id = 0;
    base::win::ScopedVariant var;
    static base::win::ScopedBstr attrID{L"id"}; 
    if (SUCCEEDED(element.getAttribute(attrID, var.Receive())) &&
        SUCCEEDED(ChangeType(var, VT_I4)))
      attributes.id = var.ptr()->intVal;
  }

  // get address
  /*{
    base::win::ScopedVariant var;
    if (SUCCEEDED(element.getAttribute(attrAddr, &var)) && var.vt != VT_NULL && SUCCEEDED(var.ChangeType(VT_BSTR))) {
      attributes.address = var.bstrVal;
      ExpandAddress(attributes.address, element);
    }
  }*/

  attributes.address = base::StringPrintf(L"CF:%d", attributes.id);

  // get CheckColor
  /*{
    attributes.color = 0;
    base::win::ScopedVariant var;
    if (SUCCEEDED(element.getAttribute(L"CheckColor", var.Receive())) &&
        SUCCEEDED(ChangeType(var, VT_BSTR))) {
      CString s(var.bstrVal); 
      s = _T("0x") + s; 
      StrToIntEx(s, STIF_SUPPORT_HEX, &attributes.color);
    }
  }*/

  return {true, attributes};
}

base::win::ScopedComPtr<IXMLDOMElement> FindElement(IXMLDOMDocument& document, const BrowseNodeId& node_id) {
  base::win::ScopedComPtr<IXMLDOMElement> element;

  if (node_id == kRootBrowseNodeId) {
    document.get_documentElement(element.Receive());

  } else {
    base::win::ScopedComPtr<IXMLDOMNode> node;
    auto s = base::StringPrintf(L"//*[@id='%d']", static_cast<int>(node_id));
    document.selectSingleNode(base::win::ScopedBstr(s.c_str()), node.Receive());
    if (node)
      node.QueryInterface(element.Receive());
  }

  return element;
}

std::vector<BrowseNode> Browse(IXMLDOMDocument& document, const BrowseNodeId& node_id) {
  std::vector<BrowseNode> nodes;

  auto parent_element = FindElement(document, node_id);
  if (!parent_element)
    return nodes;

  base::win::ScopedComPtr<IXMLDOMNodeList> children;
  if (FAILED(parent_element->get_childNodes(children.Receive())))
    return nodes;

  BrowseNode attributes{};
  while (auto node = GetNextNode(*children)) {
    base::win::ScopedComPtr<IXMLDOMElement> child;
    if (FAILED(node.QueryInterface(child.Receive())))
      continue;

    auto p = LoadNode(*child);
    if (p.first)
      nodes.emplace_back(std::move(p.second));
  }

  return nodes;
}

base::win::ScopedComPtr<IXMLDOMDocument> GetConfig(IClient& teleclient) {
  base::win::ScopedComPtr<IDispatch> disp;
  teleclient.get_XmlConfig(base::win::ScopedBstr(L"config.xml"), disp.Receive());
  if (!disp)
    return {};
  base::win::ScopedComPtr<IXMLDOMDocument> doc;
  disp.QueryInterface(doc.Receive());
  return doc;
}

VidiconConfiguration::VidiconConfiguration(scada::StandardAddressSpace& std,
                                           base::win::ScopedComPtr<IClient> teleclient)
    : ConfigurationImpl{std},
      vidicon{std},
      teleclient_{std::move(teleclient)} {
  auto cfg = GetConfig(*teleclient_);
  if (cfg)
    CreateNodes(vidicon.DataItems, *cfg, kRootBrowseNodeId);
}

void VidiconConfiguration::CreateNodes(scada::Node& parent, IXMLDOMDocument& document, const BrowseNodeId& parent_id) {
  /*for (int i = 0; i < 10; ++i) {
    auto id = scada::NodeId(i + 1, 1);
    auto name = base::StringPrintf("Folder%02d", i + 1);
    auto folder = std::make_unique<scada::Folder>(std::move(id), std::move(name));
    auto* folder_ptr = folder.get();
    AddStaticNode(std::move(folder));
    AddReference(Std.HasComponent, DataItems, *folder_ptr);

    for (int j = 0; j < 10; ++j) {
      auto id = scada::NodeId((i + 1) * 10 + j + 1, 2);
      auto name = base::StringPrintf("DataItem%02d", j + 1);
      auto data_item = std::make_unique<scada::GenericVariable>(std::move(id), std::move(name), Std.BaseDataType);
      auto* data_item_ptr = data_item.get();
      AddStaticNode(std::move(data_item));
      AddReference(Std.HasComponent, *folder_ptr, *data_item_ptr);
    }
  }*/

  for (auto& browse_node : ::Browse(document, parent_id)) {
    auto* node = CreateNode(parent, browse_node);
    CreateNodes(*node, document, browse_node.id);
  }
}

scada::Node* VidiconConfiguration::CreateNode(scada::Node& parent, const BrowseNode& browse_node) {
  auto id = scada::NodeId(browse_node.id, 1);
  auto name = base::SysWideToNativeMB(browse_node.display_name);
  if (browse_node.folder) {
    auto folder = std::make_unique<scada::Folder>(std, std::move(id), std::move(name));
    auto* folder_ptr = folder.get();
    AddStaticNode(std::move(folder));
    AddReference(std.HasComponent, parent, *folder_ptr);
    return folder_ptr;
  } else {
    std::unique_ptr<DataItem> data_item;
    base::win::ScopedComPtr<IDataPoint> point;
    teleclient_->RequestPoint(base::win::ScopedBstr(browse_node.address.c_str()), point.Receive());
    if (point) {
      base::win::ScopedVariant data_type;
      point->get_Prop(OPC_PROPERTY_DATATYPE, data_type.Receive());
      if (data_type.type() == VT_UI1 && data_type.ptr()->iVal == VT_BOOL) {
        auto discrete_item = std::make_unique<DiscreteItem>(vidicon.std, std::move(id), std::move(name), vidicon.DiscreteItemType);
        data_item = std::move(discrete_item);
      } else {
        auto analog_item = std::make_unique<AnalogItem>(vidicon.std, std::move(id), std::move(name), vidicon.AnalogItemType);
        base::win::ScopedVariant low, high;
        point->get_Prop(OPC_PROPERTY_LOW_EU, low.Receive());
        point->get_Prop(OPC_PROPERTY_HIGH_EU, high.Receive());
        if (low.ptr()->vt == VT_R8)
          analog_item->eu_lo.set_value(low.ptr()->dblVal);
        if (high.ptr()->vt == VT_R8)
          analog_item->eu_hi.set_value(high.ptr()->dblVal);
        data_item = std::move(analog_item);
      }
    }
    auto* data_item_ptr = data_item.get();
    AddStaticNode(std::move(data_item));
    AddReference(std.HasComponent, parent, *data_item_ptr);
    return data_item_ptr;
  }
}

scada::Node* VidiconConfiguration::GetNode(const scada::NodeId& node_id) {
  if (auto* node = std.GetNode(node_id))
    return node;
  else if (auto* node = vidicon.GetNode(node_id))
    return node;
  else
    return ConfigurationImpl::GetNode(node_id);
}

void VidiconConfiguration::Browse(const std::vector<scada::BrowseDescription>& nodes, const BrowseCallback& callback) {
  assert(false);
}

void VidiconConfiguration::TranslateBrowsePath(const scada::NodeId& starting_node_id, const scada::RelativePath& relative_path,
    const TranslateBrowsePathCallback& callback) {
  assert(false);
}

void VidiconConfiguration::Subscribe(scada::ViewEvents& events) {
  assert(false);
}

void VidiconConfiguration::Unsubscribe(scada::ViewEvents& events) {
  assert(false);
}
