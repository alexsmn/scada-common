// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scada.proto

#ifndef PROTOBUF_scada_2eproto__INCLUDED
#define PROTOBUF_scada_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_scada_2eproto();
void protobuf_AssignDesc_scada_2eproto();
void protobuf_ShutdownFile_scada_2eproto();

class Attributes;
class Status;
class Qualifier;
class NodeId;
class Variant;
class DataValue;
class Event;
class CreateSession;
class CreateSessionResult;
class DeleteSession;
class Node;
class CreateNode;
class CreateNodeResult;
class DeleteNode;
class DeleteNodeResult;
class ModifyNode;
class Reference;
class ChangePassword;
class ReadValueId;
class Read;
class ReadResponse;
class Write;
class DeviceCommand;
class Acknowledge;
class Call;
class EventFilter;
class HistoryRead;
class HistoryReadResult;
class CreateSubscription;
class CreateSubscriptionResult;
class DeleteSubscription;
class CreateMonitoredItem;
class CreateMonitoredItemResult;
class DeleteMonitoredItem;
class BrowseDescription;
class Browse;
class ReferenceDescription;
class BrowseResult;
class BrowseResponse;
class Request;
class Response;
class DataChange;
class SessionDeleted;
class Notification;
class Message;

enum Qualifier_Severity {
  Qualifier_Severity_GOOD = 0,
  Qualifier_Severity_UNCERTAIN = 1,
  Qualifier_Severity_BAD = 2
};
bool Qualifier_Severity_IsValid(int value);
const Qualifier_Severity Qualifier_Severity_Severity_MIN = Qualifier_Severity_GOOD;
const Qualifier_Severity Qualifier_Severity_Severity_MAX = Qualifier_Severity_BAD;
const int Qualifier_Severity_Severity_ARRAYSIZE = Qualifier_Severity_Severity_MAX + 1;

const ::google::protobuf::EnumDescriptor* Qualifier_Severity_descriptor();
inline const ::std::string& Qualifier_Severity_Name(Qualifier_Severity value) {
  return ::google::protobuf::internal::NameOfEnum(
    Qualifier_Severity_descriptor(), value);
}
inline bool Qualifier_Severity_Parse(
    const ::std::string& name, Qualifier_Severity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Qualifier_Severity>(
    Qualifier_Severity_descriptor(), name, value);
}
enum Qualifier_SubCode {
  Qualifier_SubCode_GOOD_NORMAL = 0,
  Qualifier_SubCode_GOOD_BACKUP = 1,
  Qualifier_SubCode_GOOD_MANUAL = 2,
  Qualifier_SubCode_GOOD_SIMULATED = 3,
  Qualifier_SubCode_UNCERTAIN_DEVICE = 10,
  Qualifier_SubCode_UNCERTAIN_OFFLINE = 11,
  Qualifier_SubCode_UNCERTAIN_MISCONFIGURED = 12,
  Qualifier_SubCode_UNCERTAIN_STALE = 13,
  Qualifier_SubCode_BAD_FAILED = 20
};
bool Qualifier_SubCode_IsValid(int value);
const Qualifier_SubCode Qualifier_SubCode_SubCode_MIN = Qualifier_SubCode_GOOD_NORMAL;
const Qualifier_SubCode Qualifier_SubCode_SubCode_MAX = Qualifier_SubCode_BAD_FAILED;
const int Qualifier_SubCode_SubCode_ARRAYSIZE = Qualifier_SubCode_SubCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* Qualifier_SubCode_descriptor();
inline const ::std::string& Qualifier_SubCode_Name(Qualifier_SubCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    Qualifier_SubCode_descriptor(), value);
}
inline bool Qualifier_SubCode_Parse(
    const ::std::string& name, Qualifier_SubCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Qualifier_SubCode>(
    Qualifier_SubCode_descriptor(), name, value);
}
enum Qualifier_Limit {
  Qualifier_Limit_NORMAL = 0,
  Qualifier_Limit_LO = 1,
  Qualifier_Limit_HI = 2,
  Qualifier_Limit_LOLO = 3,
  Qualifier_Limit_HIHI = 4
};
bool Qualifier_Limit_IsValid(int value);
const Qualifier_Limit Qualifier_Limit_Limit_MIN = Qualifier_Limit_NORMAL;
const Qualifier_Limit Qualifier_Limit_Limit_MAX = Qualifier_Limit_HIHI;
const int Qualifier_Limit_Limit_ARRAYSIZE = Qualifier_Limit_Limit_MAX + 1;

const ::google::protobuf::EnumDescriptor* Qualifier_Limit_descriptor();
inline const ::std::string& Qualifier_Limit_Name(Qualifier_Limit value) {
  return ::google::protobuf::internal::NameOfEnum(
    Qualifier_Limit_descriptor(), value);
}
inline bool Qualifier_Limit_Parse(
    const ::std::string& name, Qualifier_Limit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Qualifier_Limit>(
    Qualifier_Limit_descriptor(), name, value);
}
enum ProtocolVersionMajor {
  PROTOCOL_VERSION_MAJOR = 3
};
bool ProtocolVersionMajor_IsValid(int value);
const ProtocolVersionMajor ProtocolVersionMajor_MIN = PROTOCOL_VERSION_MAJOR;
const ProtocolVersionMajor ProtocolVersionMajor_MAX = PROTOCOL_VERSION_MAJOR;
const int ProtocolVersionMajor_ARRAYSIZE = ProtocolVersionMajor_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtocolVersionMajor_descriptor();
inline const ::std::string& ProtocolVersionMajor_Name(ProtocolVersionMajor value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtocolVersionMajor_descriptor(), value);
}
inline bool ProtocolVersionMajor_Parse(
    const ::std::string& name, ProtocolVersionMajor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtocolVersionMajor>(
    ProtocolVersionMajor_descriptor(), name, value);
}
enum ProtocolVersionMinor {
  PROTOCOL_VERSION_MINOR = 0
};
bool ProtocolVersionMinor_IsValid(int value);
const ProtocolVersionMinor ProtocolVersionMinor_MIN = PROTOCOL_VERSION_MINOR;
const ProtocolVersionMinor ProtocolVersionMinor_MAX = PROTOCOL_VERSION_MINOR;
const int ProtocolVersionMinor_ARRAYSIZE = ProtocolVersionMinor_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtocolVersionMinor_descriptor();
inline const ::std::string& ProtocolVersionMinor_Name(ProtocolVersionMinor value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtocolVersionMinor_descriptor(), value);
}
inline bool ProtocolVersionMinor_Parse(
    const ::std::string& name, ProtocolVersionMinor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtocolVersionMinor>(
    ProtocolVersionMinor_descriptor(), name, value);
}
enum ConstantNodeId {
  ROOT = 13,
  TYPES = 15,
  OBJECTS = 100,
  DEVICES = 109
};
bool ConstantNodeId_IsValid(int value);
const ConstantNodeId ConstantNodeId_MIN = ROOT;
const ConstantNodeId ConstantNodeId_MAX = DEVICES;
const int ConstantNodeId_ARRAYSIZE = ConstantNodeId_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConstantNodeId_descriptor();
inline const ::std::string& ConstantNodeId_Name(ConstantNodeId value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConstantNodeId_descriptor(), value);
}
inline bool ConstantNodeId_Parse(
    const ::std::string& name, ConstantNodeId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConstantNodeId>(
    ConstantNodeId_descriptor(), name, value);
}
enum AttributeId {
  NODE_ID = 1,
  NODE_CLASS = 2,
  BROWSE_NAME = 3,
  DISPLAY_NAME = 4,
  DESCRIPTION = 5,
  WriteMask = 6,
  UserWriteMask = 7,
  IsAbstract = 8,
  Symmetric = 9,
  InverseName = 10,
  ContainsNoLoops = 11,
  EVENT_NOTIFIER = 12,
  VALUE = 13,
  DATA_TYPE = 14,
  ValueRank = 15,
  ArrayDimensions = 16,
  AccessLevel = 17,
  UserAccessLevel = 18,
  MinimumSamplingInterval = 19,
  Historizing = 20,
  Executable = 21,
  UserExecutable = 22
};
bool AttributeId_IsValid(int value);
const AttributeId AttributeId_MIN = NODE_ID;
const AttributeId AttributeId_MAX = UserExecutable;
const int AttributeId_ARRAYSIZE = AttributeId_MAX + 1;

const ::google::protobuf::EnumDescriptor* AttributeId_descriptor();
inline const ::std::string& AttributeId_Name(AttributeId value) {
  return ::google::protobuf::internal::NameOfEnum(
    AttributeId_descriptor(), value);
}
inline bool AttributeId_Parse(
    const ::std::string& name, AttributeId* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AttributeId>(
    AttributeId_descriptor(), name, value);
}
enum NodeClass {
  Object = 1,
  Variable = 2,
  Method = 4,
  ObjectType = 8,
  VariableType = 16,
  ReferenceType = 32,
  DataType = 64,
  View = 128
};
bool NodeClass_IsValid(int value);
const NodeClass NodeClass_MIN = Object;
const NodeClass NodeClass_MAX = View;
const int NodeClass_ARRAYSIZE = NodeClass_MAX + 1;

const ::google::protobuf::EnumDescriptor* NodeClass_descriptor();
inline const ::std::string& NodeClass_Name(NodeClass value) {
  return ::google::protobuf::internal::NameOfEnum(
    NodeClass_descriptor(), value);
}
inline bool NodeClass_Parse(
    const ::std::string& name, NodeClass* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeClass>(
    NodeClass_descriptor(), name, value);
}
enum BrowseDirection {
  FORWARD = 0,
  INVERSE = 1,
  BOTH = 2
};
bool BrowseDirection_IsValid(int value);
const BrowseDirection BrowseDirection_MIN = FORWARD;
const BrowseDirection BrowseDirection_MAX = BOTH;
const int BrowseDirection_ARRAYSIZE = BrowseDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* BrowseDirection_descriptor();
inline const ::std::string& BrowseDirection_Name(BrowseDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    BrowseDirection_descriptor(), value);
}
inline bool BrowseDirection_Parse(
    const ::std::string& name, BrowseDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BrowseDirection>(
    BrowseDirection_descriptor(), name, value);
}
// ===================================================================

class Attributes : public ::google::protobuf::Message {
 public:
  Attributes();
  virtual ~Attributes();

  Attributes(const Attributes& from);

  inline Attributes& operator=(const Attributes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Attributes& default_instance();

  void Swap(Attributes* other);

  // implements Message ----------------------------------------------

  Attributes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Attributes& from);
  void MergeFrom(const Attributes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes browse_name = 3;
  inline bool has_browse_name() const;
  inline void clear_browse_name();
  static const int kBrowseNameFieldNumber = 3;
  inline const ::std::string& browse_name() const;
  inline void set_browse_name(const ::std::string& value);
  inline void set_browse_name(const char* value);
  inline void set_browse_name(const void* value, size_t size);
  inline ::std::string* mutable_browse_name();
  inline ::std::string* release_browse_name();
  inline void set_allocated_browse_name(::std::string* browse_name);

  // optional bytes display_name = 4;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 4;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const void* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // optional .protocol.Variant value = 13;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 13;
  inline const ::protocol::Variant& value() const;
  inline ::protocol::Variant* mutable_value();
  inline ::protocol::Variant* release_value();
  inline void set_allocated_value(::protocol::Variant* value);

  // optional .protocol.NodeId data_type_id = 14;
  inline bool has_data_type_id() const;
  inline void clear_data_type_id();
  static const int kDataTypeIdFieldNumber = 14;
  inline const ::protocol::NodeId& data_type_id() const;
  inline ::protocol::NodeId* mutable_data_type_id();
  inline ::protocol::NodeId* release_data_type_id();
  inline void set_allocated_data_type_id(::protocol::NodeId* data_type_id);

  // @@protoc_insertion_point(class_scope:protocol.Attributes)
 private:
  inline void set_has_browse_name();
  inline void clear_has_browse_name();
  inline void set_has_display_name();
  inline void clear_has_display_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_data_type_id();
  inline void clear_has_data_type_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* browse_name_;
  ::std::string* display_name_;
  ::protocol::Variant* value_;
  ::protocol::NodeId* data_type_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Attributes* default_instance_;
};
// -------------------------------------------------------------------

class Status : public ::google::protobuf::Message {
 public:
  Status();
  virtual ~Status();

  Status(const Status& from);

  inline Status& operator=(const Status& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Status& default_instance();

  void Swap(Status* other);

  // implements Message ----------------------------------------------

  Status* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Status& from);
  void MergeFrom(const Status& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 code() const;
  inline void set_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.Status)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 code_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Status* default_instance_;
};
// -------------------------------------------------------------------

class Qualifier : public ::google::protobuf::Message {
 public:
  Qualifier();
  virtual ~Qualifier();

  Qualifier(const Qualifier& from);

  inline Qualifier& operator=(const Qualifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Qualifier& default_instance();

  void Swap(Qualifier* other);

  // implements Message ----------------------------------------------

  Qualifier* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Qualifier& from);
  void MergeFrom(const Qualifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Qualifier_Severity Severity;
  static const Severity GOOD = Qualifier_Severity_GOOD;
  static const Severity UNCERTAIN = Qualifier_Severity_UNCERTAIN;
  static const Severity BAD = Qualifier_Severity_BAD;
  static inline bool Severity_IsValid(int value) {
    return Qualifier_Severity_IsValid(value);
  }
  static const Severity Severity_MIN =
    Qualifier_Severity_Severity_MIN;
  static const Severity Severity_MAX =
    Qualifier_Severity_Severity_MAX;
  static const int Severity_ARRAYSIZE =
    Qualifier_Severity_Severity_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Severity_descriptor() {
    return Qualifier_Severity_descriptor();
  }
  static inline const ::std::string& Severity_Name(Severity value) {
    return Qualifier_Severity_Name(value);
  }
  static inline bool Severity_Parse(const ::std::string& name,
      Severity* value) {
    return Qualifier_Severity_Parse(name, value);
  }

  typedef Qualifier_SubCode SubCode;
  static const SubCode GOOD_NORMAL = Qualifier_SubCode_GOOD_NORMAL;
  static const SubCode GOOD_BACKUP = Qualifier_SubCode_GOOD_BACKUP;
  static const SubCode GOOD_MANUAL = Qualifier_SubCode_GOOD_MANUAL;
  static const SubCode GOOD_SIMULATED = Qualifier_SubCode_GOOD_SIMULATED;
  static const SubCode UNCERTAIN_DEVICE = Qualifier_SubCode_UNCERTAIN_DEVICE;
  static const SubCode UNCERTAIN_OFFLINE = Qualifier_SubCode_UNCERTAIN_OFFLINE;
  static const SubCode UNCERTAIN_MISCONFIGURED = Qualifier_SubCode_UNCERTAIN_MISCONFIGURED;
  static const SubCode UNCERTAIN_STALE = Qualifier_SubCode_UNCERTAIN_STALE;
  static const SubCode BAD_FAILED = Qualifier_SubCode_BAD_FAILED;
  static inline bool SubCode_IsValid(int value) {
    return Qualifier_SubCode_IsValid(value);
  }
  static const SubCode SubCode_MIN =
    Qualifier_SubCode_SubCode_MIN;
  static const SubCode SubCode_MAX =
    Qualifier_SubCode_SubCode_MAX;
  static const int SubCode_ARRAYSIZE =
    Qualifier_SubCode_SubCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SubCode_descriptor() {
    return Qualifier_SubCode_descriptor();
  }
  static inline const ::std::string& SubCode_Name(SubCode value) {
    return Qualifier_SubCode_Name(value);
  }
  static inline bool SubCode_Parse(const ::std::string& name,
      SubCode* value) {
    return Qualifier_SubCode_Parse(name, value);
  }

  typedef Qualifier_Limit Limit;
  static const Limit NORMAL = Qualifier_Limit_NORMAL;
  static const Limit LO = Qualifier_Limit_LO;
  static const Limit HI = Qualifier_Limit_HI;
  static const Limit LOLO = Qualifier_Limit_LOLO;
  static const Limit HIHI = Qualifier_Limit_HIHI;
  static inline bool Limit_IsValid(int value) {
    return Qualifier_Limit_IsValid(value);
  }
  static const Limit Limit_MIN =
    Qualifier_Limit_Limit_MIN;
  static const Limit Limit_MAX =
    Qualifier_Limit_Limit_MAX;
  static const int Limit_ARRAYSIZE =
    Qualifier_Limit_Limit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Limit_descriptor() {
    return Qualifier_Limit_descriptor();
  }
  static inline const ::std::string& Limit_Name(Limit value) {
    return Qualifier_Limit_Name(value);
  }
  static inline bool Limit_Parse(const ::std::string& name,
      Limit* value) {
    return Qualifier_Limit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .protocol.Qualifier.Severity severity = 1;
  inline bool has_severity() const;
  inline void clear_severity();
  static const int kSeverityFieldNumber = 1;
  inline ::protocol::Qualifier_Severity severity() const;
  inline void set_severity(::protocol::Qualifier_Severity value);

  // optional .protocol.Qualifier.SubCode sub_code = 2;
  inline bool has_sub_code() const;
  inline void clear_sub_code();
  static const int kSubCodeFieldNumber = 2;
  inline ::protocol::Qualifier_SubCode sub_code() const;
  inline void set_sub_code(::protocol::Qualifier_SubCode value);

  // optional .protocol.Qualifier.Limit limit = 3;
  inline bool has_limit() const;
  inline void clear_limit();
  static const int kLimitFieldNumber = 3;
  inline ::protocol::Qualifier_Limit limit() const;
  inline void set_limit(::protocol::Qualifier_Limit value);

  // @@protoc_insertion_point(class_scope:protocol.Qualifier)
 private:
  inline void set_has_severity();
  inline void clear_has_severity();
  inline void set_has_sub_code();
  inline void clear_has_sub_code();
  inline void set_has_limit();
  inline void clear_has_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int severity_;
  int sub_code_;
  int limit_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Qualifier* default_instance_;
};
// -------------------------------------------------------------------

class NodeId : public ::google::protobuf::Message {
 public:
  NodeId();
  virtual ~NodeId();

  NodeId(const NodeId& from);

  inline NodeId& operator=(const NodeId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeId& default_instance();

  void Swap(NodeId* other);

  // implements Message ----------------------------------------------

  NodeId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NodeId& from);
  void MergeFrom(const NodeId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 namespace_index = 1;
  inline bool has_namespace_index() const;
  inline void clear_namespace_index();
  static const int kNamespaceIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 namespace_index() const;
  inline void set_namespace_index(::google::protobuf::uint32 value);

  // optional uint32 numeric_id = 2;
  inline bool has_numeric_id() const;
  inline void clear_numeric_id();
  static const int kNumericIdFieldNumber = 2;
  inline ::google::protobuf::uint32 numeric_id() const;
  inline void set_numeric_id(::google::protobuf::uint32 value);

  // optional string string_id = 3;
  inline bool has_string_id() const;
  inline void clear_string_id();
  static const int kStringIdFieldNumber = 3;
  inline const ::std::string& string_id() const;
  inline void set_string_id(const ::std::string& value);
  inline void set_string_id(const char* value);
  inline void set_string_id(const char* value, size_t size);
  inline ::std::string* mutable_string_id();
  inline ::std::string* release_string_id();
  inline void set_allocated_string_id(::std::string* string_id);

  // optional bytes opaque_id = 4;
  inline bool has_opaque_id() const;
  inline void clear_opaque_id();
  static const int kOpaqueIdFieldNumber = 4;
  inline const ::std::string& opaque_id() const;
  inline void set_opaque_id(const ::std::string& value);
  inline void set_opaque_id(const char* value);
  inline void set_opaque_id(const void* value, size_t size);
  inline ::std::string* mutable_opaque_id();
  inline ::std::string* release_opaque_id();
  inline void set_allocated_opaque_id(::std::string* opaque_id);

  // @@protoc_insertion_point(class_scope:protocol.NodeId)
 private:
  inline void set_has_namespace_index();
  inline void clear_has_namespace_index();
  inline void set_has_numeric_id();
  inline void clear_has_numeric_id();
  inline void set_has_string_id();
  inline void clear_has_string_id();
  inline void set_has_opaque_id();
  inline void clear_has_opaque_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 namespace_index_;
  ::google::protobuf::uint32 numeric_id_;
  ::std::string* string_id_;
  ::std::string* opaque_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static NodeId* default_instance_;
};
// -------------------------------------------------------------------

class Variant : public ::google::protobuf::Message {
 public:
  Variant();
  virtual ~Variant();

  Variant(const Variant& from);

  inline Variant& operator=(const Variant& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Variant& default_instance();

  void Swap(Variant* other);

  // implements Message ----------------------------------------------

  Variant* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Variant& from);
  void MergeFrom(const Variant& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool bool_value = 1;
  inline bool has_bool_value() const;
  inline void clear_bool_value();
  static const int kBoolValueFieldNumber = 1;
  inline bool bool_value() const;
  inline void set_bool_value(bool value);

  // optional int32 int32_value = 2;
  inline bool has_int32_value() const;
  inline void clear_int32_value();
  static const int kInt32ValueFieldNumber = 2;
  inline ::google::protobuf::int32 int32_value() const;
  inline void set_int32_value(::google::protobuf::int32 value);

  // optional int64 int64_value = 3;
  inline bool has_int64_value() const;
  inline void clear_int64_value();
  static const int kInt64ValueFieldNumber = 3;
  inline ::google::protobuf::int64 int64_value() const;
  inline void set_int64_value(::google::protobuf::int64 value);

  // optional double double_value = 4;
  inline bool has_double_value() const;
  inline void clear_double_value();
  static const int kDoubleValueFieldNumber = 4;
  inline double double_value() const;
  inline void set_double_value(double value);

  // optional bytes string_value = 5;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 5;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const void* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // optional .protocol.NodeId node_id_value = 6;
  inline bool has_node_id_value() const;
  inline void clear_node_id_value();
  static const int kNodeIdValueFieldNumber = 6;
  inline const ::protocol::NodeId& node_id_value() const;
  inline ::protocol::NodeId* mutable_node_id_value();
  inline ::protocol::NodeId* release_node_id_value();
  inline void set_allocated_node_id_value(::protocol::NodeId* node_id_value);

  // optional bytes localized_text_value = 7;
  inline bool has_localized_text_value() const;
  inline void clear_localized_text_value();
  static const int kLocalizedTextValueFieldNumber = 7;
  inline const ::std::string& localized_text_value() const;
  inline void set_localized_text_value(const ::std::string& value);
  inline void set_localized_text_value(const char* value);
  inline void set_localized_text_value(const void* value, size_t size);
  inline ::std::string* mutable_localized_text_value();
  inline ::std::string* release_localized_text_value();
  inline void set_allocated_localized_text_value(::std::string* localized_text_value);

  // @@protoc_insertion_point(class_scope:protocol.Variant)
 private:
  inline void set_has_bool_value();
  inline void clear_has_bool_value();
  inline void set_has_int32_value();
  inline void clear_has_int32_value();
  inline void set_has_int64_value();
  inline void clear_has_int64_value();
  inline void set_has_double_value();
  inline void clear_has_double_value();
  inline void set_has_string_value();
  inline void clear_has_string_value();
  inline void set_has_node_id_value();
  inline void clear_has_node_id_value();
  inline void set_has_localized_text_value();
  inline void clear_has_localized_text_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool bool_value_;
  ::google::protobuf::int32 int32_value_;
  ::google::protobuf::int64 int64_value_;
  double double_value_;
  ::std::string* string_value_;
  ::protocol::NodeId* node_id_value_;
  ::std::string* localized_text_value_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Variant* default_instance_;
};
// -------------------------------------------------------------------

class DataValue : public ::google::protobuf::Message {
 public:
  DataValue();
  virtual ~DataValue();

  DataValue(const DataValue& from);

  inline DataValue& operator=(const DataValue& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataValue& default_instance();

  void Swap(DataValue* other);

  // implements Message ----------------------------------------------

  DataValue* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataValue& from);
  void MergeFrom(const DataValue& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 server_timestamp = 1;
  inline bool has_server_timestamp() const;
  inline void clear_server_timestamp();
  static const int kServerTimestampFieldNumber = 1;
  inline ::google::protobuf::uint64 server_timestamp() const;
  inline void set_server_timestamp(::google::protobuf::uint64 value);

  // optional uint64 source_timestamp = 2;
  inline bool has_source_timestamp() const;
  inline void clear_source_timestamp();
  static const int kSourceTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 source_timestamp() const;
  inline void set_source_timestamp(::google::protobuf::uint64 value);

  // optional .protocol.Variant value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::protocol::Variant& value() const;
  inline ::protocol::Variant* mutable_value();
  inline ::protocol::Variant* release_value();
  inline void set_allocated_value(::protocol::Variant* value);

  // required uint32 qualifier = 4;
  inline bool has_qualifier() const;
  inline void clear_qualifier();
  static const int kQualifierFieldNumber = 4;
  inline ::google::protobuf::uint32 qualifier() const;
  inline void set_qualifier(::google::protobuf::uint32 value);

  // optional uint32 status_code = 5;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 5;
  inline ::google::protobuf::uint32 status_code() const;
  inline void set_status_code(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.DataValue)
 private:
  inline void set_has_server_timestamp();
  inline void clear_has_server_timestamp();
  inline void set_has_source_timestamp();
  inline void clear_has_source_timestamp();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_qualifier();
  inline void clear_has_qualifier();
  inline void set_has_status_code();
  inline void clear_has_status_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 server_timestamp_;
  ::google::protobuf::uint64 source_timestamp_;
  ::protocol::Variant* value_;
  ::google::protobuf::uint32 qualifier_;
  ::google::protobuf::uint32 status_code_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static DataValue* default_instance_;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  Event* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 monitored_item_id = 1;
  inline bool has_monitored_item_id() const;
  inline void clear_monitored_item_id();
  static const int kMonitoredItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 monitored_item_id() const;
  inline void set_monitored_item_id(::google::protobuf::uint32 value);

  // required uint64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);

  // required uint32 severity = 3;
  inline bool has_severity() const;
  inline void clear_severity();
  static const int kSeverityFieldNumber = 3;
  inline ::google::protobuf::uint32 severity() const;
  inline void set_severity(::google::protobuf::uint32 value);

  // optional .protocol.NodeId source_node_id = 4;
  inline bool has_source_node_id() const;
  inline void clear_source_node_id();
  static const int kSourceNodeIdFieldNumber = 4;
  inline const ::protocol::NodeId& source_node_id() const;
  inline ::protocol::NodeId* mutable_source_node_id();
  inline ::protocol::NodeId* release_source_node_id();
  inline void set_allocated_source_node_id(::protocol::NodeId* source_node_id);

  // optional .protocol.NodeId user_node_id = 5;
  inline bool has_user_node_id() const;
  inline void clear_user_node_id();
  static const int kUserNodeIdFieldNumber = 5;
  inline const ::protocol::NodeId& user_node_id() const;
  inline ::protocol::NodeId* mutable_user_node_id();
  inline ::protocol::NodeId* release_user_node_id();
  inline void set_allocated_user_node_id(::protocol::NodeId* user_node_id);

  // optional .protocol.Variant value = 6;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 6;
  inline const ::protocol::Variant& value() const;
  inline ::protocol::Variant* mutable_value();
  inline ::protocol::Variant* release_value();
  inline void set_allocated_value(::protocol::Variant* value);

  // optional uint32 qualifier = 7;
  inline bool has_qualifier() const;
  inline void clear_qualifier();
  static const int kQualifierFieldNumber = 7;
  inline ::google::protobuf::uint32 qualifier() const;
  inline void set_qualifier(::google::protobuf::uint32 value);

  // optional bytes message = 8;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 8;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const void* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional bool acknowledged = 9;
  inline bool has_acknowledged() const;
  inline void clear_acknowledged();
  static const int kAcknowledgedFieldNumber = 9;
  inline bool acknowledged() const;
  inline void set_acknowledged(bool value);

  // optional uint64 acknowledge_id = 10;
  inline bool has_acknowledge_id() const;
  inline void clear_acknowledge_id();
  static const int kAcknowledgeIdFieldNumber = 10;
  inline ::google::protobuf::uint64 acknowledge_id() const;
  inline void set_acknowledge_id(::google::protobuf::uint64 value);

  // optional uint64 acknowledge_time = 11;
  inline bool has_acknowledge_time() const;
  inline void clear_acknowledge_time();
  static const int kAcknowledgeTimeFieldNumber = 11;
  inline ::google::protobuf::uint64 acknowledge_time() const;
  inline void set_acknowledge_time(::google::protobuf::uint64 value);

  // optional .protocol.NodeId acknowledge_user_id = 12;
  inline bool has_acknowledge_user_id() const;
  inline void clear_acknowledge_user_id();
  static const int kAcknowledgeUserIdFieldNumber = 12;
  inline const ::protocol::NodeId& acknowledge_user_id() const;
  inline ::protocol::NodeId* mutable_acknowledge_user_id();
  inline ::protocol::NodeId* release_acknowledge_user_id();
  inline void set_allocated_acknowledge_user_id(::protocol::NodeId* acknowledge_user_id);

  // @@protoc_insertion_point(class_scope:protocol.Event)
 private:
  inline void set_has_monitored_item_id();
  inline void clear_has_monitored_item_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_severity();
  inline void clear_has_severity();
  inline void set_has_source_node_id();
  inline void clear_has_source_node_id();
  inline void set_has_user_node_id();
  inline void clear_has_user_node_id();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_qualifier();
  inline void clear_has_qualifier();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_acknowledged();
  inline void clear_has_acknowledged();
  inline void set_has_acknowledge_id();
  inline void clear_has_acknowledge_id();
  inline void set_has_acknowledge_time();
  inline void clear_has_acknowledge_time();
  inline void set_has_acknowledge_user_id();
  inline void clear_has_acknowledge_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 time_;
  ::google::protobuf::uint32 monitored_item_id_;
  ::google::protobuf::uint32 severity_;
  ::protocol::NodeId* source_node_id_;
  ::protocol::NodeId* user_node_id_;
  ::protocol::Variant* value_;
  ::std::string* message_;
  ::google::protobuf::uint32 qualifier_;
  bool acknowledged_;
  ::google::protobuf::uint64 acknowledge_id_;
  ::google::protobuf::uint64 acknowledge_time_;
  ::protocol::NodeId* acknowledge_user_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Event* default_instance_;
};
// -------------------------------------------------------------------

class CreateSession : public ::google::protobuf::Message {
 public:
  CreateSession();
  virtual ~CreateSession();

  CreateSession(const CreateSession& from);

  inline CreateSession& operator=(const CreateSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSession& default_instance();

  void Swap(CreateSession* other);

  // implements Message ----------------------------------------------

  CreateSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSession& from);
  void MergeFrom(const CreateSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes user_name = 1;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 1;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const void* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // optional bytes password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const void* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional bool delete_existing = 3;
  inline bool has_delete_existing() const;
  inline void clear_delete_existing();
  static const int kDeleteExistingFieldNumber = 3;
  inline bool delete_existing() const;
  inline void set_delete_existing(bool value);

  // required uint32 protocol_version_major = 4;
  inline bool has_protocol_version_major() const;
  inline void clear_protocol_version_major();
  static const int kProtocolVersionMajorFieldNumber = 4;
  inline ::google::protobuf::uint32 protocol_version_major() const;
  inline void set_protocol_version_major(::google::protobuf::uint32 value);

  // required uint32 protocol_version_minor = 5;
  inline bool has_protocol_version_minor() const;
  inline void clear_protocol_version_minor();
  static const int kProtocolVersionMinorFieldNumber = 5;
  inline ::google::protobuf::uint32 protocol_version_minor() const;
  inline void set_protocol_version_minor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.CreateSession)
 private:
  inline void set_has_user_name();
  inline void clear_has_user_name();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_delete_existing();
  inline void clear_has_delete_existing();
  inline void set_has_protocol_version_major();
  inline void clear_has_protocol_version_major();
  inline void set_has_protocol_version_minor();
  inline void clear_has_protocol_version_minor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* user_name_;
  ::std::string* password_;
  bool delete_existing_;
  ::google::protobuf::uint32 protocol_version_major_;
  ::google::protobuf::uint32 protocol_version_minor_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static CreateSession* default_instance_;
};
// -------------------------------------------------------------------

class CreateSessionResult : public ::google::protobuf::Message {
 public:
  CreateSessionResult();
  virtual ~CreateSessionResult();

  CreateSessionResult(const CreateSessionResult& from);

  inline CreateSessionResult& operator=(const CreateSessionResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSessionResult& default_instance();

  void Swap(CreateSessionResult* other);

  // implements Message ----------------------------------------------

  CreateSessionResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSessionResult& from);
  void MergeFrom(const CreateSessionResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional .protocol.NodeId user_node_id = 2;
  inline bool has_user_node_id() const;
  inline void clear_user_node_id();
  static const int kUserNodeIdFieldNumber = 2;
  inline const ::protocol::NodeId& user_node_id() const;
  inline ::protocol::NodeId* mutable_user_node_id();
  inline ::protocol::NodeId* release_user_node_id();
  inline void set_allocated_user_node_id(::protocol::NodeId* user_node_id);

  // optional uint32 user_rights = 3;
  inline bool has_user_rights() const;
  inline void clear_user_rights();
  static const int kUserRightsFieldNumber = 3;
  inline ::google::protobuf::uint32 user_rights() const;
  inline void set_user_rights(::google::protobuf::uint32 value);

  // required uint32 protocol_version_major = 4;
  inline bool has_protocol_version_major() const;
  inline void clear_protocol_version_major();
  static const int kProtocolVersionMajorFieldNumber = 4;
  inline ::google::protobuf::uint32 protocol_version_major() const;
  inline void set_protocol_version_major(::google::protobuf::uint32 value);

  // required uint32 protocol_version_minor = 5;
  inline bool has_protocol_version_minor() const;
  inline void clear_protocol_version_minor();
  static const int kProtocolVersionMinorFieldNumber = 5;
  inline ::google::protobuf::uint32 protocol_version_minor() const;
  inline void set_protocol_version_minor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.CreateSessionResult)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_user_node_id();
  inline void clear_has_user_node_id();
  inline void set_has_user_rights();
  inline void clear_has_user_rights();
  inline void set_has_protocol_version_major();
  inline void clear_has_protocol_version_major();
  inline void set_has_protocol_version_minor();
  inline void clear_has_protocol_version_minor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* token_;
  ::protocol::NodeId* user_node_id_;
  ::google::protobuf::uint32 user_rights_;
  ::google::protobuf::uint32 protocol_version_major_;
  ::google::protobuf::uint32 protocol_version_minor_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static CreateSessionResult* default_instance_;
};
// -------------------------------------------------------------------

class DeleteSession : public ::google::protobuf::Message {
 public:
  DeleteSession();
  virtual ~DeleteSession();

  DeleteSession(const DeleteSession& from);

  inline DeleteSession& operator=(const DeleteSession& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteSession& default_instance();

  void Swap(DeleteSession* other);

  // implements Message ----------------------------------------------

  DeleteSession* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteSession& from);
  void MergeFrom(const DeleteSession& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:protocol.DeleteSession)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* token_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static DeleteSession* default_instance_;
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  void Swap(Node* other);

  // implements Message ----------------------------------------------

  Node* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // optional .protocol.NodeId type_id = 2;
  inline bool has_type_id() const;
  inline void clear_type_id();
  static const int kTypeIdFieldNumber = 2;
  inline const ::protocol::NodeId& type_id() const;
  inline ::protocol::NodeId* mutable_type_id();
  inline ::protocol::NodeId* release_type_id();
  inline void set_allocated_type_id(::protocol::NodeId* type_id);

  // optional .protocol.NodeClass node_class = 3;
  inline bool has_node_class() const;
  inline void clear_node_class();
  static const int kNodeClassFieldNumber = 3;
  inline ::protocol::NodeClass node_class() const;
  inline void set_node_class(::protocol::NodeClass value);

  // optional .protocol.Attributes attributes = 5;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline const ::protocol::Attributes& attributes() const;
  inline ::protocol::Attributes* mutable_attributes();
  inline ::protocol::Attributes* release_attributes();
  inline void set_allocated_attributes(::protocol::Attributes* attributes);

  // optional .protocol.NodeId parent_id = 6;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 6;
  inline const ::protocol::NodeId& parent_id() const;
  inline ::protocol::NodeId* mutable_parent_id();
  inline ::protocol::NodeId* release_parent_id();
  inline void set_allocated_parent_id(::protocol::NodeId* parent_id);

  // optional .protocol.NodeId reference_type_id = 7;
  inline bool has_reference_type_id() const;
  inline void clear_reference_type_id();
  static const int kReferenceTypeIdFieldNumber = 7;
  inline const ::protocol::NodeId& reference_type_id() const;
  inline ::protocol::NodeId* mutable_reference_type_id();
  inline ::protocol::NodeId* release_reference_type_id();
  inline void set_allocated_reference_type_id(::protocol::NodeId* reference_type_id);

  // @@protoc_insertion_point(class_scope:protocol.Node)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_type_id();
  inline void clear_has_type_id();
  inline void set_has_node_class();
  inline void clear_has_node_class();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_reference_type_id();
  inline void clear_has_reference_type_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  ::protocol::NodeId* type_id_;
  ::protocol::Attributes* attributes_;
  ::protocol::NodeId* parent_id_;
  ::protocol::NodeId* reference_type_id_;
  int node_class_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Node* default_instance_;
};
// -------------------------------------------------------------------

class CreateNode : public ::google::protobuf::Message {
 public:
  CreateNode();
  virtual ~CreateNode();

  CreateNode(const CreateNode& from);

  inline CreateNode& operator=(const CreateNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateNode& default_instance();

  void Swap(CreateNode* other);

  // implements Message ----------------------------------------------

  CreateNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateNode& from);
  void MergeFrom(const CreateNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.NodeId requested_node_id = 1;
  inline bool has_requested_node_id() const;
  inline void clear_requested_node_id();
  static const int kRequestedNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& requested_node_id() const;
  inline ::protocol::NodeId* mutable_requested_node_id();
  inline ::protocol::NodeId* release_requested_node_id();
  inline void set_allocated_requested_node_id(::protocol::NodeId* requested_node_id);

  // required .protocol.NodeId type_id = 2;
  inline bool has_type_id() const;
  inline void clear_type_id();
  static const int kTypeIdFieldNumber = 2;
  inline const ::protocol::NodeId& type_id() const;
  inline ::protocol::NodeId* mutable_type_id();
  inline ::protocol::NodeId* release_type_id();
  inline void set_allocated_type_id(::protocol::NodeId* type_id);

  // required .protocol.NodeId parent_id = 3;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 3;
  inline const ::protocol::NodeId& parent_id() const;
  inline ::protocol::NodeId* mutable_parent_id();
  inline ::protocol::NodeId* release_parent_id();
  inline void set_allocated_parent_id(::protocol::NodeId* parent_id);

  // required .protocol.NodeClass node_class = 5;
  inline bool has_node_class() const;
  inline void clear_node_class();
  static const int kNodeClassFieldNumber = 5;
  inline ::protocol::NodeClass node_class() const;
  inline void set_node_class(::protocol::NodeClass value);

  // optional .protocol.Attributes attributes = 6;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 6;
  inline const ::protocol::Attributes& attributes() const;
  inline ::protocol::Attributes* mutable_attributes();
  inline ::protocol::Attributes* release_attributes();
  inline void set_allocated_attributes(::protocol::Attributes* attributes);

  // @@protoc_insertion_point(class_scope:protocol.CreateNode)
 private:
  inline void set_has_requested_node_id();
  inline void clear_has_requested_node_id();
  inline void set_has_type_id();
  inline void clear_has_type_id();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_node_class();
  inline void clear_has_node_class();
  inline void set_has_attributes();
  inline void clear_has_attributes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* requested_node_id_;
  ::protocol::NodeId* type_id_;
  ::protocol::NodeId* parent_id_;
  ::protocol::Attributes* attributes_;
  int node_class_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static CreateNode* default_instance_;
};
// -------------------------------------------------------------------

class CreateNodeResult : public ::google::protobuf::Message {
 public:
  CreateNodeResult();
  virtual ~CreateNodeResult();

  CreateNodeResult(const CreateNodeResult& from);

  inline CreateNodeResult& operator=(const CreateNodeResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateNodeResult& default_instance();

  void Swap(CreateNodeResult* other);

  // implements Message ----------------------------------------------

  CreateNodeResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateNodeResult& from);
  void MergeFrom(const CreateNodeResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // @@protoc_insertion_point(class_scope:protocol.CreateNodeResult)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static CreateNodeResult* default_instance_;
};
// -------------------------------------------------------------------

class DeleteNode : public ::google::protobuf::Message {
 public:
  DeleteNode();
  virtual ~DeleteNode();

  DeleteNode(const DeleteNode& from);

  inline DeleteNode& operator=(const DeleteNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteNode& default_instance();

  void Swap(DeleteNode* other);

  // implements Message ----------------------------------------------

  DeleteNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteNode& from);
  void MergeFrom(const DeleteNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 2;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // optional bool return_references = 10;
  inline bool has_return_references() const;
  inline void clear_return_references();
  static const int kReturnReferencesFieldNumber = 10;
  inline bool return_references() const;
  inline void set_return_references(bool value);

  // @@protoc_insertion_point(class_scope:protocol.DeleteNode)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_return_references();
  inline void clear_has_return_references();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  bool return_references_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static DeleteNode* default_instance_;
};
// -------------------------------------------------------------------

class DeleteNodeResult : public ::google::protobuf::Message {
 public:
  DeleteNodeResult();
  virtual ~DeleteNodeResult();

  DeleteNodeResult(const DeleteNodeResult& from);

  inline DeleteNodeResult& operator=(const DeleteNodeResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteNodeResult& default_instance();

  void Swap(DeleteNodeResult* other);

  // implements Message ----------------------------------------------

  DeleteNodeResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteNodeResult& from);
  void MergeFrom(const DeleteNodeResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.NodeId references = 1;
  inline int references_size() const;
  inline void clear_references();
  static const int kReferencesFieldNumber = 1;
  inline const ::protocol::NodeId& references(int index) const;
  inline ::protocol::NodeId* mutable_references(int index);
  inline ::protocol::NodeId* add_references();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >&
      references() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >*
      mutable_references();

  // @@protoc_insertion_point(class_scope:protocol.DeleteNodeResult)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::NodeId > references_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static DeleteNodeResult* default_instance_;
};
// -------------------------------------------------------------------

class ModifyNode : public ::google::protobuf::Message {
 public:
  ModifyNode();
  virtual ~ModifyNode();

  ModifyNode(const ModifyNode& from);

  inline ModifyNode& operator=(const ModifyNode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyNode& default_instance();

  void Swap(ModifyNode* other);

  // implements Message ----------------------------------------------

  ModifyNode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModifyNode& from);
  void MergeFrom(const ModifyNode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // optional .protocol.Attributes attributes = 2;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 2;
  inline const ::protocol::Attributes& attributes() const;
  inline ::protocol::Attributes* mutable_attributes();
  inline ::protocol::Attributes* release_attributes();
  inline void set_allocated_attributes(::protocol::Attributes* attributes);

  // @@protoc_insertion_point(class_scope:protocol.ModifyNode)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_attributes();
  inline void clear_has_attributes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  ::protocol::Attributes* attributes_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static ModifyNode* default_instance_;
};
// -------------------------------------------------------------------

class Reference : public ::google::protobuf::Message {
 public:
  Reference();
  virtual ~Reference();

  Reference(const Reference& from);

  inline Reference& operator=(const Reference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Reference& default_instance();

  void Swap(Reference* other);

  // implements Message ----------------------------------------------

  Reference* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Reference& from);
  void MergeFrom(const Reference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId reference_type_id = 1;
  inline bool has_reference_type_id() const;
  inline void clear_reference_type_id();
  static const int kReferenceTypeIdFieldNumber = 1;
  inline const ::protocol::NodeId& reference_type_id() const;
  inline ::protocol::NodeId* mutable_reference_type_id();
  inline ::protocol::NodeId* release_reference_type_id();
  inline void set_allocated_reference_type_id(::protocol::NodeId* reference_type_id);

  // required .protocol.NodeId source_id = 2;
  inline bool has_source_id() const;
  inline void clear_source_id();
  static const int kSourceIdFieldNumber = 2;
  inline const ::protocol::NodeId& source_id() const;
  inline ::protocol::NodeId* mutable_source_id();
  inline ::protocol::NodeId* release_source_id();
  inline void set_allocated_source_id(::protocol::NodeId* source_id);

  // required .protocol.NodeId target_id = 3;
  inline bool has_target_id() const;
  inline void clear_target_id();
  static const int kTargetIdFieldNumber = 3;
  inline const ::protocol::NodeId& target_id() const;
  inline ::protocol::NodeId* mutable_target_id();
  inline ::protocol::NodeId* release_target_id();
  inline void set_allocated_target_id(::protocol::NodeId* target_id);

  // @@protoc_insertion_point(class_scope:protocol.Reference)
 private:
  inline void set_has_reference_type_id();
  inline void clear_has_reference_type_id();
  inline void set_has_source_id();
  inline void clear_has_source_id();
  inline void set_has_target_id();
  inline void clear_has_target_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* reference_type_id_;
  ::protocol::NodeId* source_id_;
  ::protocol::NodeId* target_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Reference* default_instance_;
};
// -------------------------------------------------------------------

class ChangePassword : public ::google::protobuf::Message {
 public:
  ChangePassword();
  virtual ~ChangePassword();

  ChangePassword(const ChangePassword& from);

  inline ChangePassword& operator=(const ChangePassword& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangePassword& default_instance();

  void Swap(ChangePassword* other);

  // implements Message ----------------------------------------------

  ChangePassword* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangePassword& from);
  void MergeFrom(const ChangePassword& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId user_node_id = 1;
  inline bool has_user_node_id() const;
  inline void clear_user_node_id();
  static const int kUserNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& user_node_id() const;
  inline ::protocol::NodeId* mutable_user_node_id();
  inline ::protocol::NodeId* release_user_node_id();
  inline void set_allocated_user_node_id(::protocol::NodeId* user_node_id);

  // required bytes current_password = 2;
  inline bool has_current_password() const;
  inline void clear_current_password();
  static const int kCurrentPasswordFieldNumber = 2;
  inline const ::std::string& current_password() const;
  inline void set_current_password(const ::std::string& value);
  inline void set_current_password(const char* value);
  inline void set_current_password(const void* value, size_t size);
  inline ::std::string* mutable_current_password();
  inline ::std::string* release_current_password();
  inline void set_allocated_current_password(::std::string* current_password);

  // required bytes new_password = 3;
  inline bool has_new_password() const;
  inline void clear_new_password();
  static const int kNewPasswordFieldNumber = 3;
  inline const ::std::string& new_password() const;
  inline void set_new_password(const ::std::string& value);
  inline void set_new_password(const char* value);
  inline void set_new_password(const void* value, size_t size);
  inline ::std::string* mutable_new_password();
  inline ::std::string* release_new_password();
  inline void set_allocated_new_password(::std::string* new_password);

  // @@protoc_insertion_point(class_scope:protocol.ChangePassword)
 private:
  inline void set_has_user_node_id();
  inline void clear_has_user_node_id();
  inline void set_has_current_password();
  inline void clear_has_current_password();
  inline void set_has_new_password();
  inline void clear_has_new_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* user_node_id_;
  ::std::string* current_password_;
  ::std::string* new_password_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static ChangePassword* default_instance_;
};
// -------------------------------------------------------------------

class ReadValueId : public ::google::protobuf::Message {
 public:
  ReadValueId();
  virtual ~ReadValueId();

  ReadValueId(const ReadValueId& from);

  inline ReadValueId& operator=(const ReadValueId& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadValueId& default_instance();

  void Swap(ReadValueId* other);

  // implements Message ----------------------------------------------

  ReadValueId* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadValueId& from);
  void MergeFrom(const ReadValueId& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // required .protocol.AttributeId attribute_id = 2;
  inline bool has_attribute_id() const;
  inline void clear_attribute_id();
  static const int kAttributeIdFieldNumber = 2;
  inline ::protocol::AttributeId attribute_id() const;
  inline void set_attribute_id(::protocol::AttributeId value);

  // @@protoc_insertion_point(class_scope:protocol.ReadValueId)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_attribute_id();
  inline void clear_has_attribute_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  int attribute_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static ReadValueId* default_instance_;
};
// -------------------------------------------------------------------

class Read : public ::google::protobuf::Message {
 public:
  Read();
  virtual ~Read();

  Read(const Read& from);

  inline Read& operator=(const Read& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Read& default_instance();

  void Swap(Read* other);

  // implements Message ----------------------------------------------

  Read* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Read& from);
  void MergeFrom(const Read& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.ReadValueId value_id = 1;
  inline int value_id_size() const;
  inline void clear_value_id();
  static const int kValueIdFieldNumber = 1;
  inline const ::protocol::ReadValueId& value_id(int index) const;
  inline ::protocol::ReadValueId* mutable_value_id(int index);
  inline ::protocol::ReadValueId* add_value_id();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::ReadValueId >&
      value_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::ReadValueId >*
      mutable_value_id();

  // @@protoc_insertion_point(class_scope:protocol.Read)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::ReadValueId > value_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Read* default_instance_;
};
// -------------------------------------------------------------------

class ReadResponse : public ::google::protobuf::Message {
 public:
  ReadResponse();
  virtual ~ReadResponse();

  ReadResponse(const ReadResponse& from);

  inline ReadResponse& operator=(const ReadResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadResponse& default_instance();

  void Swap(ReadResponse* other);

  // implements Message ----------------------------------------------

  ReadResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReadResponse& from);
  void MergeFrom(const ReadResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.DataValue result = 1;
  inline int result_size() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::protocol::DataValue& result(int index) const;
  inline ::protocol::DataValue* mutable_result(int index);
  inline ::protocol::DataValue* add_result();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::DataValue >&
      result() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::DataValue >*
      mutable_result();

  // @@protoc_insertion_point(class_scope:protocol.ReadResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::DataValue > result_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static ReadResponse* default_instance_;
};
// -------------------------------------------------------------------

class Write : public ::google::protobuf::Message {
 public:
  Write();
  virtual ~Write();

  Write(const Write& from);

  inline Write& operator=(const Write& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Write& default_instance();

  void Swap(Write* other);

  // implements Message ----------------------------------------------

  Write* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Write& from);
  void MergeFrom(const Write& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // required double value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline double value() const;
  inline void set_value(double value);

  // optional bool select = 5;
  inline bool has_select() const;
  inline void clear_select();
  static const int kSelectFieldNumber = 5;
  inline bool select() const;
  inline void set_select(bool value);

  // @@protoc_insertion_point(class_scope:protocol.Write)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_select();
  inline void clear_has_select();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  double value_;
  bool select_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Write* default_instance_;
};
// -------------------------------------------------------------------

class DeviceCommand : public ::google::protobuf::Message {
 public:
  DeviceCommand();
  virtual ~DeviceCommand();

  DeviceCommand(const DeviceCommand& from);

  inline DeviceCommand& operator=(const DeviceCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceCommand& default_instance();

  void Swap(DeviceCommand* other);

  // implements Message ----------------------------------------------

  DeviceCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceCommand& from);
  void MergeFrom(const DeviceCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // required .protocol.NodeId method_id = 2;
  inline bool has_method_id() const;
  inline void clear_method_id();
  static const int kMethodIdFieldNumber = 2;
  inline const ::protocol::NodeId& method_id() const;
  inline ::protocol::NodeId* mutable_method_id();
  inline ::protocol::NodeId* release_method_id();
  inline void set_allocated_method_id(::protocol::NodeId* method_id);

  // repeated .protocol.Variant argument = 3;
  inline int argument_size() const;
  inline void clear_argument();
  static const int kArgumentFieldNumber = 3;
  inline const ::protocol::Variant& argument(int index) const;
  inline ::protocol::Variant* mutable_argument(int index);
  inline ::protocol::Variant* add_argument();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Variant >&
      argument() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Variant >*
      mutable_argument();

  // @@protoc_insertion_point(class_scope:protocol.DeviceCommand)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_method_id();
  inline void clear_has_method_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  ::protocol::NodeId* method_id_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Variant > argument_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static DeviceCommand* default_instance_;
};
// -------------------------------------------------------------------

class Acknowledge : public ::google::protobuf::Message {
 public:
  Acknowledge();
  virtual ~Acknowledge();

  Acknowledge(const Acknowledge& from);

  inline Acknowledge& operator=(const Acknowledge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Acknowledge& default_instance();

  void Swap(Acknowledge* other);

  // implements Message ----------------------------------------------

  Acknowledge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Acknowledge& from);
  void MergeFrom(const Acknowledge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 event_id = 1;
  inline bool has_event_id() const;
  inline void clear_event_id();
  static const int kEventIdFieldNumber = 1;
  inline ::google::protobuf::uint64 event_id() const;
  inline void set_event_id(::google::protobuf::uint64 value);

  // optional bytes comment = 2;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 2;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const void* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:protocol.Acknowledge)
 private:
  inline void set_has_event_id();
  inline void clear_has_event_id();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 event_id_;
  ::std::string* comment_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Acknowledge* default_instance_;
};
// -------------------------------------------------------------------

class Call : public ::google::protobuf::Message {
 public:
  Call();
  virtual ~Call();

  Call(const Call& from);

  inline Call& operator=(const Call& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Call& default_instance();

  void Swap(Call* other);

  // implements Message ----------------------------------------------

  Call* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Call& from);
  void MergeFrom(const Call& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocol.DeviceCommand device_command = 1;
  inline bool has_device_command() const;
  inline void clear_device_command();
  static const int kDeviceCommandFieldNumber = 1;
  inline const ::protocol::DeviceCommand& device_command() const;
  inline ::protocol::DeviceCommand* mutable_device_command();
  inline ::protocol::DeviceCommand* release_device_command();
  inline void set_allocated_device_command(::protocol::DeviceCommand* device_command);

  // optional .protocol.Acknowledge acknowledge = 2;
  inline bool has_acknowledge() const;
  inline void clear_acknowledge();
  static const int kAcknowledgeFieldNumber = 2;
  inline const ::protocol::Acknowledge& acknowledge() const;
  inline ::protocol::Acknowledge* mutable_acknowledge();
  inline ::protocol::Acknowledge* release_acknowledge();
  inline void set_allocated_acknowledge(::protocol::Acknowledge* acknowledge);

  // @@protoc_insertion_point(class_scope:protocol.Call)
 private:
  inline void set_has_device_command();
  inline void clear_has_device_command();
  inline void set_has_acknowledge();
  inline void clear_has_acknowledge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::DeviceCommand* device_command_;
  ::protocol::Acknowledge* acknowledge_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Call* default_instance_;
};
// -------------------------------------------------------------------

class EventFilter : public ::google::protobuf::Message {
 public:
  EventFilter();
  virtual ~EventFilter();

  EventFilter(const EventFilter& from);

  inline EventFilter& operator=(const EventFilter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EventFilter& default_instance();

  void Swap(EventFilter* other);

  // implements Message ----------------------------------------------

  EventFilter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EventFilter& from);
  void MergeFrom(const EventFilter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool acked = 1;
  inline bool has_acked() const;
  inline void clear_acked();
  static const int kAckedFieldNumber = 1;
  inline bool acked() const;
  inline void set_acked(bool value);

  // optional bool unacked = 2;
  inline bool has_unacked() const;
  inline void clear_unacked();
  static const int kUnackedFieldNumber = 2;
  inline bool unacked() const;
  inline void set_unacked(bool value);

  // @@protoc_insertion_point(class_scope:protocol.EventFilter)
 private:
  inline void set_has_acked();
  inline void clear_has_acked();
  inline void set_has_unacked();
  inline void clear_has_unacked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool acked_;
  bool unacked_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static EventFilter* default_instance_;
};
// -------------------------------------------------------------------

class HistoryRead : public ::google::protobuf::Message {
 public:
  HistoryRead();
  virtual ~HistoryRead();

  HistoryRead(const HistoryRead& from);

  inline HistoryRead& operator=(const HistoryRead& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryRead& default_instance();

  void Swap(HistoryRead* other);

  // implements Message ----------------------------------------------

  HistoryRead* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryRead& from);
  void MergeFrom(const HistoryRead& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // required .protocol.AttributeId attribute_id = 2;
  inline bool has_attribute_id() const;
  inline void clear_attribute_id();
  static const int kAttributeIdFieldNumber = 2;
  inline ::protocol::AttributeId attribute_id() const;
  inline void set_attribute_id(::protocol::AttributeId value);

  // required uint64 from = 3;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 3;
  inline ::google::protobuf::uint64 from() const;
  inline void set_from(::google::protobuf::uint64 value);

  // optional uint64 to = 4;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 4;
  inline ::google::protobuf::uint64 to() const;
  inline void set_to(::google::protobuf::uint64 value);

  // optional .protocol.EventFilter event_filter = 5;
  inline bool has_event_filter() const;
  inline void clear_event_filter();
  static const int kEventFilterFieldNumber = 5;
  inline const ::protocol::EventFilter& event_filter() const;
  inline ::protocol::EventFilter* mutable_event_filter();
  inline ::protocol::EventFilter* release_event_filter();
  inline void set_allocated_event_filter(::protocol::EventFilter* event_filter);

  // @@protoc_insertion_point(class_scope:protocol.HistoryRead)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_attribute_id();
  inline void clear_has_attribute_id();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_event_filter();
  inline void clear_has_event_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  ::google::protobuf::uint64 from_;
  ::google::protobuf::uint64 to_;
  ::protocol::EventFilter* event_filter_;
  int attribute_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static HistoryRead* default_instance_;
};
// -------------------------------------------------------------------

class HistoryReadResult : public ::google::protobuf::Message {
 public:
  HistoryReadResult();
  virtual ~HistoryReadResult();

  HistoryReadResult(const HistoryReadResult& from);

  inline HistoryReadResult& operator=(const HistoryReadResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HistoryReadResult& default_instance();

  void Swap(HistoryReadResult* other);

  // implements Message ----------------------------------------------

  HistoryReadResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HistoryReadResult& from);
  void MergeFrom(const HistoryReadResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.DataValue values = 1;
  inline int values_size() const;
  inline void clear_values();
  static const int kValuesFieldNumber = 1;
  inline const ::protocol::DataValue& values(int index) const;
  inline ::protocol::DataValue* mutable_values(int index);
  inline ::protocol::DataValue* add_values();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::DataValue >&
      values() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::DataValue >*
      mutable_values();

  // repeated .protocol.Event events = 2;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 2;
  inline const ::protocol::Event& events(int index) const;
  inline ::protocol::Event* mutable_events(int index);
  inline ::protocol::Event* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Event >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Event >*
      mutable_events();

  // @@protoc_insertion_point(class_scope:protocol.HistoryReadResult)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::DataValue > values_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Event > events_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static HistoryReadResult* default_instance_;
};
// -------------------------------------------------------------------

class CreateSubscription : public ::google::protobuf::Message {
 public:
  CreateSubscription();
  virtual ~CreateSubscription();

  CreateSubscription(const CreateSubscription& from);

  inline CreateSubscription& operator=(const CreateSubscription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSubscription& default_instance();

  void Swap(CreateSubscription* other);

  // implements Message ----------------------------------------------

  CreateSubscription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSubscription& from);
  void MergeFrom(const CreateSubscription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 update_rate_ms = 1;
  inline bool has_update_rate_ms() const;
  inline void clear_update_rate_ms();
  static const int kUpdateRateMsFieldNumber = 1;
  inline ::google::protobuf::uint32 update_rate_ms() const;
  inline void set_update_rate_ms(::google::protobuf::uint32 value);

  // optional .protocol.EventFilter event_filter = 2;
  inline bool has_event_filter() const;
  inline void clear_event_filter();
  static const int kEventFilterFieldNumber = 2;
  inline const ::protocol::EventFilter& event_filter() const;
  inline ::protocol::EventFilter* mutable_event_filter();
  inline ::protocol::EventFilter* release_event_filter();
  inline void set_allocated_event_filter(::protocol::EventFilter* event_filter);

  // @@protoc_insertion_point(class_scope:protocol.CreateSubscription)
 private:
  inline void set_has_update_rate_ms();
  inline void clear_has_update_rate_ms();
  inline void set_has_event_filter();
  inline void clear_has_event_filter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::EventFilter* event_filter_;
  ::google::protobuf::uint32 update_rate_ms_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static CreateSubscription* default_instance_;
};
// -------------------------------------------------------------------

class CreateSubscriptionResult : public ::google::protobuf::Message {
 public:
  CreateSubscriptionResult();
  virtual ~CreateSubscriptionResult();

  CreateSubscriptionResult(const CreateSubscriptionResult& from);

  inline CreateSubscriptionResult& operator=(const CreateSubscriptionResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateSubscriptionResult& default_instance();

  void Swap(CreateSubscriptionResult* other);

  // implements Message ----------------------------------------------

  CreateSubscriptionResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateSubscriptionResult& from);
  void MergeFrom(const CreateSubscriptionResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 subscription_id = 1;
  inline bool has_subscription_id() const;
  inline void clear_subscription_id();
  static const int kSubscriptionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 subscription_id() const;
  inline void set_subscription_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.CreateSubscriptionResult)
 private:
  inline void set_has_subscription_id();
  inline void clear_has_subscription_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 subscription_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static CreateSubscriptionResult* default_instance_;
};
// -------------------------------------------------------------------

class DeleteSubscription : public ::google::protobuf::Message {
 public:
  DeleteSubscription();
  virtual ~DeleteSubscription();

  DeleteSubscription(const DeleteSubscription& from);

  inline DeleteSubscription& operator=(const DeleteSubscription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteSubscription& default_instance();

  void Swap(DeleteSubscription* other);

  // implements Message ----------------------------------------------

  DeleteSubscription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteSubscription& from);
  void MergeFrom(const DeleteSubscription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 subscription_id = 1;
  inline bool has_subscription_id() const;
  inline void clear_subscription_id();
  static const int kSubscriptionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 subscription_id() const;
  inline void set_subscription_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.DeleteSubscription)
 private:
  inline void set_has_subscription_id();
  inline void clear_has_subscription_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 subscription_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static DeleteSubscription* default_instance_;
};
// -------------------------------------------------------------------

class CreateMonitoredItem : public ::google::protobuf::Message {
 public:
  CreateMonitoredItem();
  virtual ~CreateMonitoredItem();

  CreateMonitoredItem(const CreateMonitoredItem& from);

  inline CreateMonitoredItem& operator=(const CreateMonitoredItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateMonitoredItem& default_instance();

  void Swap(CreateMonitoredItem* other);

  // implements Message ----------------------------------------------

  CreateMonitoredItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateMonitoredItem& from);
  void MergeFrom(const CreateMonitoredItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 subscription_id = 1;
  inline bool has_subscription_id() const;
  inline void clear_subscription_id();
  static const int kSubscriptionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 subscription_id() const;
  inline void set_subscription_id(::google::protobuf::uint32 value);

  // required .protocol.NodeId node_id = 2;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 2;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // required .protocol.AttributeId attribute_id = 3;
  inline bool has_attribute_id() const;
  inline void clear_attribute_id();
  static const int kAttributeIdFieldNumber = 3;
  inline ::protocol::AttributeId attribute_id() const;
  inline void set_attribute_id(::protocol::AttributeId value);

  // @@protoc_insertion_point(class_scope:protocol.CreateMonitoredItem)
 private:
  inline void set_has_subscription_id();
  inline void clear_has_subscription_id();
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_attribute_id();
  inline void clear_has_attribute_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  ::google::protobuf::uint32 subscription_id_;
  int attribute_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static CreateMonitoredItem* default_instance_;
};
// -------------------------------------------------------------------

class CreateMonitoredItemResult : public ::google::protobuf::Message {
 public:
  CreateMonitoredItemResult();
  virtual ~CreateMonitoredItemResult();

  CreateMonitoredItemResult(const CreateMonitoredItemResult& from);

  inline CreateMonitoredItemResult& operator=(const CreateMonitoredItemResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateMonitoredItemResult& default_instance();

  void Swap(CreateMonitoredItemResult* other);

  // implements Message ----------------------------------------------

  CreateMonitoredItemResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateMonitoredItemResult& from);
  void MergeFrom(const CreateMonitoredItemResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 monitored_item_id = 21;
  inline bool has_monitored_item_id() const;
  inline void clear_monitored_item_id();
  static const int kMonitoredItemIdFieldNumber = 21;
  inline ::google::protobuf::uint32 monitored_item_id() const;
  inline void set_monitored_item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.CreateMonitoredItemResult)
 private:
  inline void set_has_monitored_item_id();
  inline void clear_has_monitored_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 monitored_item_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static CreateMonitoredItemResult* default_instance_;
};
// -------------------------------------------------------------------

class DeleteMonitoredItem : public ::google::protobuf::Message {
 public:
  DeleteMonitoredItem();
  virtual ~DeleteMonitoredItem();

  DeleteMonitoredItem(const DeleteMonitoredItem& from);

  inline DeleteMonitoredItem& operator=(const DeleteMonitoredItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteMonitoredItem& default_instance();

  void Swap(DeleteMonitoredItem* other);

  // implements Message ----------------------------------------------

  DeleteMonitoredItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeleteMonitoredItem& from);
  void MergeFrom(const DeleteMonitoredItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 subscription_id = 1;
  inline bool has_subscription_id() const;
  inline void clear_subscription_id();
  static const int kSubscriptionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 subscription_id() const;
  inline void set_subscription_id(::google::protobuf::uint32 value);

  // required uint32 monitored_item_id = 2;
  inline bool has_monitored_item_id() const;
  inline void clear_monitored_item_id();
  static const int kMonitoredItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 monitored_item_id() const;
  inline void set_monitored_item_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protocol.DeleteMonitoredItem)
 private:
  inline void set_has_subscription_id();
  inline void clear_has_subscription_id();
  inline void set_has_monitored_item_id();
  inline void clear_has_monitored_item_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 subscription_id_;
  ::google::protobuf::uint32 monitored_item_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static DeleteMonitoredItem* default_instance_;
};
// -------------------------------------------------------------------

class BrowseDescription : public ::google::protobuf::Message {
 public:
  BrowseDescription();
  virtual ~BrowseDescription();

  BrowseDescription(const BrowseDescription& from);

  inline BrowseDescription& operator=(const BrowseDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BrowseDescription& default_instance();

  void Swap(BrowseDescription* other);

  // implements Message ----------------------------------------------

  BrowseDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrowseDescription& from);
  void MergeFrom(const BrowseDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId node_id = 1;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // optional .protocol.BrowseDirection direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline ::protocol::BrowseDirection direction() const;
  inline void set_direction(::protocol::BrowseDirection value);

  // optional .protocol.NodeId reference_type_id = 3;
  inline bool has_reference_type_id() const;
  inline void clear_reference_type_id();
  static const int kReferenceTypeIdFieldNumber = 3;
  inline const ::protocol::NodeId& reference_type_id() const;
  inline ::protocol::NodeId* mutable_reference_type_id();
  inline ::protocol::NodeId* release_reference_type_id();
  inline void set_allocated_reference_type_id(::protocol::NodeId* reference_type_id);

  // optional bool include_subtypes = 4;
  inline bool has_include_subtypes() const;
  inline void clear_include_subtypes();
  static const int kIncludeSubtypesFieldNumber = 4;
  inline bool include_subtypes() const;
  inline void set_include_subtypes(bool value);

  // @@protoc_insertion_point(class_scope:protocol.BrowseDescription)
 private:
  inline void set_has_node_id();
  inline void clear_has_node_id();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_reference_type_id();
  inline void clear_has_reference_type_id();
  inline void set_has_include_subtypes();
  inline void clear_has_include_subtypes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* node_id_;
  ::protocol::NodeId* reference_type_id_;
  int direction_;
  bool include_subtypes_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static BrowseDescription* default_instance_;
};
// -------------------------------------------------------------------

class Browse : public ::google::protobuf::Message {
 public:
  Browse();
  virtual ~Browse();

  Browse(const Browse& from);

  inline Browse& operator=(const Browse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Browse& default_instance();

  void Swap(Browse* other);

  // implements Message ----------------------------------------------

  Browse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Browse& from);
  void MergeFrom(const Browse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.BrowseDescription nodes = 1;
  inline int nodes_size() const;
  inline void clear_nodes();
  static const int kNodesFieldNumber = 1;
  inline const ::protocol::BrowseDescription& nodes(int index) const;
  inline ::protocol::BrowseDescription* mutable_nodes(int index);
  inline ::protocol::BrowseDescription* add_nodes();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::BrowseDescription >&
      nodes() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::BrowseDescription >*
      mutable_nodes();

  // @@protoc_insertion_point(class_scope:protocol.Browse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::BrowseDescription > nodes_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Browse* default_instance_;
};
// -------------------------------------------------------------------

class ReferenceDescription : public ::google::protobuf::Message {
 public:
  ReferenceDescription();
  virtual ~ReferenceDescription();

  ReferenceDescription(const ReferenceDescription& from);

  inline ReferenceDescription& operator=(const ReferenceDescription& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReferenceDescription& default_instance();

  void Swap(ReferenceDescription* other);

  // implements Message ----------------------------------------------

  ReferenceDescription* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReferenceDescription& from);
  void MergeFrom(const ReferenceDescription& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.NodeId reference_type_id = 1;
  inline bool has_reference_type_id() const;
  inline void clear_reference_type_id();
  static const int kReferenceTypeIdFieldNumber = 1;
  inline const ::protocol::NodeId& reference_type_id() const;
  inline ::protocol::NodeId* mutable_reference_type_id();
  inline ::protocol::NodeId* release_reference_type_id();
  inline void set_allocated_reference_type_id(::protocol::NodeId* reference_type_id);

  // required bool forward = 2;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kForwardFieldNumber = 2;
  inline bool forward() const;
  inline void set_forward(bool value);

  // required .protocol.NodeId node_id = 3;
  inline bool has_node_id() const;
  inline void clear_node_id();
  static const int kNodeIdFieldNumber = 3;
  inline const ::protocol::NodeId& node_id() const;
  inline ::protocol::NodeId* mutable_node_id();
  inline ::protocol::NodeId* release_node_id();
  inline void set_allocated_node_id(::protocol::NodeId* node_id);

  // @@protoc_insertion_point(class_scope:protocol.ReferenceDescription)
 private:
  inline void set_has_reference_type_id();
  inline void clear_has_reference_type_id();
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_node_id();
  inline void clear_has_node_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::NodeId* reference_type_id_;
  ::protocol::NodeId* node_id_;
  bool forward_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static ReferenceDescription* default_instance_;
};
// -------------------------------------------------------------------

class BrowseResult : public ::google::protobuf::Message {
 public:
  BrowseResult();
  virtual ~BrowseResult();

  BrowseResult(const BrowseResult& from);

  inline BrowseResult& operator=(const BrowseResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BrowseResult& default_instance();

  void Swap(BrowseResult* other);

  // implements Message ----------------------------------------------

  BrowseResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrowseResult& from);
  void MergeFrom(const BrowseResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 status_code = 1;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  inline ::google::protobuf::uint32 status_code() const;
  inline void set_status_code(::google::protobuf::uint32 value);

  // repeated .protocol.ReferenceDescription references = 2;
  inline int references_size() const;
  inline void clear_references();
  static const int kReferencesFieldNumber = 2;
  inline const ::protocol::ReferenceDescription& references(int index) const;
  inline ::protocol::ReferenceDescription* mutable_references(int index);
  inline ::protocol::ReferenceDescription* add_references();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::ReferenceDescription >&
      references() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::ReferenceDescription >*
      mutable_references();

  // @@protoc_insertion_point(class_scope:protocol.BrowseResult)
 private:
  inline void set_has_status_code();
  inline void clear_has_status_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::ReferenceDescription > references_;
  ::google::protobuf::uint32 status_code_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static BrowseResult* default_instance_;
};
// -------------------------------------------------------------------

class BrowseResponse : public ::google::protobuf::Message {
 public:
  BrowseResponse();
  virtual ~BrowseResponse();

  BrowseResponse(const BrowseResponse& from);

  inline BrowseResponse& operator=(const BrowseResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BrowseResponse& default_instance();

  void Swap(BrowseResponse* other);

  // implements Message ----------------------------------------------

  BrowseResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BrowseResponse& from);
  void MergeFrom(const BrowseResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .protocol.Status status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::protocol::Status& status() const;
  inline ::protocol::Status* mutable_status();
  inline ::protocol::Status* release_status();
  inline void set_allocated_status(::protocol::Status* status);

  // repeated .protocol.BrowseResult results = 2;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 2;
  inline const ::protocol::BrowseResult& results(int index) const;
  inline ::protocol::BrowseResult* mutable_results(int index);
  inline ::protocol::BrowseResult* add_results();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::BrowseResult >&
      results() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::BrowseResult >*
      mutable_results();

  // @@protoc_insertion_point(class_scope:protocol.BrowseResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::Status* status_;
  ::google::protobuf::RepeatedPtrField< ::protocol::BrowseResult > results_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static BrowseResponse* default_instance_;
};
// -------------------------------------------------------------------

class Request : public ::google::protobuf::Message {
 public:
  Request();
  virtual ~Request();

  Request(const Request& from);

  inline Request& operator=(const Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Request& default_instance();

  void Swap(Request* other);

  // implements Message ----------------------------------------------

  Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Request& from);
  void MergeFrom(const Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 request_id() const;
  inline void set_request_id(::google::protobuf::uint32 value);

  // optional .protocol.CreateSession create_session = 10;
  inline bool has_create_session() const;
  inline void clear_create_session();
  static const int kCreateSessionFieldNumber = 10;
  inline const ::protocol::CreateSession& create_session() const;
  inline ::protocol::CreateSession* mutable_create_session();
  inline ::protocol::CreateSession* release_create_session();
  inline void set_allocated_create_session(::protocol::CreateSession* create_session);

  // optional .protocol.DeleteSession delete_session = 11;
  inline bool has_delete_session() const;
  inline void clear_delete_session();
  static const int kDeleteSessionFieldNumber = 11;
  inline const ::protocol::DeleteSession& delete_session() const;
  inline ::protocol::DeleteSession* mutable_delete_session();
  inline ::protocol::DeleteSession* release_delete_session();
  inline void set_allocated_delete_session(::protocol::DeleteSession* delete_session);

  // optional .protocol.Read read = 14;
  inline bool has_read() const;
  inline void clear_read();
  static const int kReadFieldNumber = 14;
  inline const ::protocol::Read& read() const;
  inline ::protocol::Read* mutable_read();
  inline ::protocol::Read* release_read();
  inline void set_allocated_read(::protocol::Read* read);

  // optional .protocol.Write write = 12;
  inline bool has_write() const;
  inline void clear_write();
  static const int kWriteFieldNumber = 12;
  inline const ::protocol::Write& write() const;
  inline ::protocol::Write* mutable_write();
  inline ::protocol::Write* release_write();
  inline void set_allocated_write(::protocol::Write* write);

  // optional .protocol.Call call = 13;
  inline bool has_call() const;
  inline void clear_call();
  static const int kCallFieldNumber = 13;
  inline const ::protocol::Call& call() const;
  inline ::protocol::Call* mutable_call();
  inline ::protocol::Call* release_call();
  inline void set_allocated_call(::protocol::Call* call);

  // optional .protocol.CreateSubscription create_subscription = 20;
  inline bool has_create_subscription() const;
  inline void clear_create_subscription();
  static const int kCreateSubscriptionFieldNumber = 20;
  inline const ::protocol::CreateSubscription& create_subscription() const;
  inline ::protocol::CreateSubscription* mutable_create_subscription();
  inline ::protocol::CreateSubscription* release_create_subscription();
  inline void set_allocated_create_subscription(::protocol::CreateSubscription* create_subscription);

  // optional .protocol.DeleteSubscription delete_subscription = 21;
  inline bool has_delete_subscription() const;
  inline void clear_delete_subscription();
  static const int kDeleteSubscriptionFieldNumber = 21;
  inline const ::protocol::DeleteSubscription& delete_subscription() const;
  inline ::protocol::DeleteSubscription* mutable_delete_subscription();
  inline ::protocol::DeleteSubscription* release_delete_subscription();
  inline void set_allocated_delete_subscription(::protocol::DeleteSubscription* delete_subscription);

  // optional .protocol.CreateMonitoredItem create_monitored_item = 30;
  inline bool has_create_monitored_item() const;
  inline void clear_create_monitored_item();
  static const int kCreateMonitoredItemFieldNumber = 30;
  inline const ::protocol::CreateMonitoredItem& create_monitored_item() const;
  inline ::protocol::CreateMonitoredItem* mutable_create_monitored_item();
  inline ::protocol::CreateMonitoredItem* release_create_monitored_item();
  inline void set_allocated_create_monitored_item(::protocol::CreateMonitoredItem* create_monitored_item);

  // optional .protocol.DeleteMonitoredItem delete_monitored_item = 31;
  inline bool has_delete_monitored_item() const;
  inline void clear_delete_monitored_item();
  static const int kDeleteMonitoredItemFieldNumber = 31;
  inline const ::protocol::DeleteMonitoredItem& delete_monitored_item() const;
  inline ::protocol::DeleteMonitoredItem* mutable_delete_monitored_item();
  inline ::protocol::DeleteMonitoredItem* release_delete_monitored_item();
  inline void set_allocated_delete_monitored_item(::protocol::DeleteMonitoredItem* delete_monitored_item);

  // optional .protocol.HistoryRead history_read = 40;
  inline bool has_history_read() const;
  inline void clear_history_read();
  static const int kHistoryReadFieldNumber = 40;
  inline const ::protocol::HistoryRead& history_read() const;
  inline ::protocol::HistoryRead* mutable_history_read();
  inline ::protocol::HistoryRead* release_history_read();
  inline void set_allocated_history_read(::protocol::HistoryRead* history_read);

  // optional .protocol.CreateNode create_node = 50;
  inline bool has_create_node() const;
  inline void clear_create_node();
  static const int kCreateNodeFieldNumber = 50;
  inline const ::protocol::CreateNode& create_node() const;
  inline ::protocol::CreateNode* mutable_create_node();
  inline ::protocol::CreateNode* release_create_node();
  inline void set_allocated_create_node(::protocol::CreateNode* create_node);

  // optional .protocol.DeleteNode delete_node = 51;
  inline bool has_delete_node() const;
  inline void clear_delete_node();
  static const int kDeleteNodeFieldNumber = 51;
  inline const ::protocol::DeleteNode& delete_node() const;
  inline ::protocol::DeleteNode* mutable_delete_node();
  inline ::protocol::DeleteNode* release_delete_node();
  inline void set_allocated_delete_node(::protocol::DeleteNode* delete_node);

  // repeated .protocol.ModifyNode modify_node = 52;
  inline int modify_node_size() const;
  inline void clear_modify_node();
  static const int kModifyNodeFieldNumber = 52;
  inline const ::protocol::ModifyNode& modify_node(int index) const;
  inline ::protocol::ModifyNode* mutable_modify_node(int index);
  inline ::protocol::ModifyNode* add_modify_node();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::ModifyNode >&
      modify_node() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::ModifyNode >*
      mutable_modify_node();

  // optional .protocol.Reference add_reference = 54;
  inline bool has_add_reference() const;
  inline void clear_add_reference();
  static const int kAddReferenceFieldNumber = 54;
  inline const ::protocol::Reference& add_reference() const;
  inline ::protocol::Reference* mutable_add_reference();
  inline ::protocol::Reference* release_add_reference();
  inline void set_allocated_add_reference(::protocol::Reference* add_reference);

  // optional .protocol.Reference delete_reference = 55;
  inline bool has_delete_reference() const;
  inline void clear_delete_reference();
  static const int kDeleteReferenceFieldNumber = 55;
  inline const ::protocol::Reference& delete_reference() const;
  inline ::protocol::Reference* mutable_delete_reference();
  inline ::protocol::Reference* release_delete_reference();
  inline void set_allocated_delete_reference(::protocol::Reference* delete_reference);

  // optional .protocol.ChangePassword change_password = 53;
  inline bool has_change_password() const;
  inline void clear_change_password();
  static const int kChangePasswordFieldNumber = 53;
  inline const ::protocol::ChangePassword& change_password() const;
  inline ::protocol::ChangePassword* mutable_change_password();
  inline ::protocol::ChangePassword* release_change_password();
  inline void set_allocated_change_password(::protocol::ChangePassword* change_password);

  // optional .protocol.Browse browse = 60;
  inline bool has_browse() const;
  inline void clear_browse();
  static const int kBrowseFieldNumber = 60;
  inline const ::protocol::Browse& browse() const;
  inline ::protocol::Browse* mutable_browse();
  inline ::protocol::Browse* release_browse();
  inline void set_allocated_browse(::protocol::Browse* browse);

  // @@protoc_insertion_point(class_scope:protocol.Request)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_create_session();
  inline void clear_has_create_session();
  inline void set_has_delete_session();
  inline void clear_has_delete_session();
  inline void set_has_read();
  inline void clear_has_read();
  inline void set_has_write();
  inline void clear_has_write();
  inline void set_has_call();
  inline void clear_has_call();
  inline void set_has_create_subscription();
  inline void clear_has_create_subscription();
  inline void set_has_delete_subscription();
  inline void clear_has_delete_subscription();
  inline void set_has_create_monitored_item();
  inline void clear_has_create_monitored_item();
  inline void set_has_delete_monitored_item();
  inline void clear_has_delete_monitored_item();
  inline void set_has_history_read();
  inline void clear_has_history_read();
  inline void set_has_create_node();
  inline void clear_has_create_node();
  inline void set_has_delete_node();
  inline void clear_has_delete_node();
  inline void set_has_add_reference();
  inline void clear_has_add_reference();
  inline void set_has_delete_reference();
  inline void clear_has_delete_reference();
  inline void set_has_change_password();
  inline void clear_has_change_password();
  inline void set_has_browse();
  inline void clear_has_browse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::CreateSession* create_session_;
  ::protocol::DeleteSession* delete_session_;
  ::protocol::Read* read_;
  ::protocol::Write* write_;
  ::protocol::Call* call_;
  ::protocol::CreateSubscription* create_subscription_;
  ::protocol::DeleteSubscription* delete_subscription_;
  ::protocol::CreateMonitoredItem* create_monitored_item_;
  ::protocol::DeleteMonitoredItem* delete_monitored_item_;
  ::protocol::HistoryRead* history_read_;
  ::protocol::CreateNode* create_node_;
  ::protocol::DeleteNode* delete_node_;
  ::google::protobuf::RepeatedPtrField< ::protocol::ModifyNode > modify_node_;
  ::protocol::Reference* add_reference_;
  ::protocol::Reference* delete_reference_;
  ::protocol::ChangePassword* change_password_;
  ::protocol::Browse* browse_;
  ::google::protobuf::uint32 request_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Request* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 request_id = 1;
  inline bool has_request_id() const;
  inline void clear_request_id();
  static const int kRequestIdFieldNumber = 1;
  inline ::google::protobuf::uint32 request_id() const;
  inline void set_request_id(::google::protobuf::uint32 value);

  // repeated .protocol.Status status = 2;
  inline int status_size() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline const ::protocol::Status& status(int index) const;
  inline ::protocol::Status* mutable_status(int index);
  inline ::protocol::Status* add_status();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Status >&
      status() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Status >*
      mutable_status();

  // optional .protocol.CreateSessionResult create_session_result = 10;
  inline bool has_create_session_result() const;
  inline void clear_create_session_result();
  static const int kCreateSessionResultFieldNumber = 10;
  inline const ::protocol::CreateSessionResult& create_session_result() const;
  inline ::protocol::CreateSessionResult* mutable_create_session_result();
  inline ::protocol::CreateSessionResult* release_create_session_result();
  inline void set_allocated_create_session_result(::protocol::CreateSessionResult* create_session_result);

  // optional .protocol.ReadResponse read = 14;
  inline bool has_read() const;
  inline void clear_read();
  static const int kReadFieldNumber = 14;
  inline const ::protocol::ReadResponse& read() const;
  inline ::protocol::ReadResponse* mutable_read();
  inline ::protocol::ReadResponse* release_read();
  inline void set_allocated_read(::protocol::ReadResponse* read);

  // optional .protocol.CreateSubscriptionResult create_subscription_result = 20;
  inline bool has_create_subscription_result() const;
  inline void clear_create_subscription_result();
  static const int kCreateSubscriptionResultFieldNumber = 20;
  inline const ::protocol::CreateSubscriptionResult& create_subscription_result() const;
  inline ::protocol::CreateSubscriptionResult* mutable_create_subscription_result();
  inline ::protocol::CreateSubscriptionResult* release_create_subscription_result();
  inline void set_allocated_create_subscription_result(::protocol::CreateSubscriptionResult* create_subscription_result);

  // optional .protocol.CreateMonitoredItemResult create_monitored_item_result = 30;
  inline bool has_create_monitored_item_result() const;
  inline void clear_create_monitored_item_result();
  static const int kCreateMonitoredItemResultFieldNumber = 30;
  inline const ::protocol::CreateMonitoredItemResult& create_monitored_item_result() const;
  inline ::protocol::CreateMonitoredItemResult* mutable_create_monitored_item_result();
  inline ::protocol::CreateMonitoredItemResult* release_create_monitored_item_result();
  inline void set_allocated_create_monitored_item_result(::protocol::CreateMonitoredItemResult* create_monitored_item_result);

  // optional .protocol.HistoryReadResult history_read_result = 40;
  inline bool has_history_read_result() const;
  inline void clear_history_read_result();
  static const int kHistoryReadResultFieldNumber = 40;
  inline const ::protocol::HistoryReadResult& history_read_result() const;
  inline ::protocol::HistoryReadResult* mutable_history_read_result();
  inline ::protocol::HistoryReadResult* release_history_read_result();
  inline void set_allocated_history_read_result(::protocol::HistoryReadResult* history_read_result);

  // optional .protocol.CreateNodeResult create_node_result = 50;
  inline bool has_create_node_result() const;
  inline void clear_create_node_result();
  static const int kCreateNodeResultFieldNumber = 50;
  inline const ::protocol::CreateNodeResult& create_node_result() const;
  inline ::protocol::CreateNodeResult* mutable_create_node_result();
  inline ::protocol::CreateNodeResult* release_create_node_result();
  inline void set_allocated_create_node_result(::protocol::CreateNodeResult* create_node_result);

  // optional .protocol.DeleteNodeResult delete_node_result = 51;
  inline bool has_delete_node_result() const;
  inline void clear_delete_node_result();
  static const int kDeleteNodeResultFieldNumber = 51;
  inline const ::protocol::DeleteNodeResult& delete_node_result() const;
  inline ::protocol::DeleteNodeResult* mutable_delete_node_result();
  inline ::protocol::DeleteNodeResult* release_delete_node_result();
  inline void set_allocated_delete_node_result(::protocol::DeleteNodeResult* delete_node_result);

  // optional .protocol.BrowseResponse browse = 60;
  inline bool has_browse() const;
  inline void clear_browse();
  static const int kBrowseFieldNumber = 60;
  inline const ::protocol::BrowseResponse& browse() const;
  inline ::protocol::BrowseResponse* mutable_browse();
  inline ::protocol::BrowseResponse* release_browse();
  inline void set_allocated_browse(::protocol::BrowseResponse* browse);

  // @@protoc_insertion_point(class_scope:protocol.Response)
 private:
  inline void set_has_request_id();
  inline void clear_has_request_id();
  inline void set_has_create_session_result();
  inline void clear_has_create_session_result();
  inline void set_has_read();
  inline void clear_has_read();
  inline void set_has_create_subscription_result();
  inline void clear_has_create_subscription_result();
  inline void set_has_create_monitored_item_result();
  inline void clear_has_create_monitored_item_result();
  inline void set_has_history_read_result();
  inline void clear_has_history_read_result();
  inline void set_has_create_node_result();
  inline void clear_has_create_node_result();
  inline void set_has_delete_node_result();
  inline void clear_has_delete_node_result();
  inline void set_has_browse();
  inline void clear_has_browse();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Status > status_;
  ::protocol::CreateSessionResult* create_session_result_;
  ::protocol::ReadResponse* read_;
  ::protocol::CreateSubscriptionResult* create_subscription_result_;
  ::protocol::CreateMonitoredItemResult* create_monitored_item_result_;
  ::protocol::HistoryReadResult* history_read_result_;
  ::protocol::CreateNodeResult* create_node_result_;
  ::protocol::DeleteNodeResult* delete_node_result_;
  ::protocol::BrowseResponse* browse_;
  ::google::protobuf::uint32 request_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class DataChange : public ::google::protobuf::Message {
 public:
  DataChange();
  virtual ~DataChange();

  DataChange(const DataChange& from);

  inline DataChange& operator=(const DataChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataChange& default_instance();

  void Swap(DataChange* other);

  // implements Message ----------------------------------------------

  DataChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DataChange& from);
  void MergeFrom(const DataChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 monitored_item_id = 1;
  inline bool has_monitored_item_id() const;
  inline void clear_monitored_item_id();
  static const int kMonitoredItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 monitored_item_id() const;
  inline void set_monitored_item_id(::google::protobuf::uint32 value);

  // required .protocol.DataValue data_value = 2;
  inline bool has_data_value() const;
  inline void clear_data_value();
  static const int kDataValueFieldNumber = 2;
  inline const ::protocol::DataValue& data_value() const;
  inline ::protocol::DataValue* mutable_data_value();
  inline ::protocol::DataValue* release_data_value();
  inline void set_allocated_data_value(::protocol::DataValue* data_value);

  // @@protoc_insertion_point(class_scope:protocol.DataChange)
 private:
  inline void set_has_monitored_item_id();
  inline void clear_has_monitored_item_id();
  inline void set_has_data_value();
  inline void clear_has_data_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::protocol::DataValue* data_value_;
  ::google::protobuf::uint32 monitored_item_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static DataChange* default_instance_;
};
// -------------------------------------------------------------------

class SessionDeleted : public ::google::protobuf::Message {
 public:
  SessionDeleted();
  virtual ~SessionDeleted();

  SessionDeleted(const SessionDeleted& from);

  inline SessionDeleted& operator=(const SessionDeleted& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionDeleted& default_instance();

  void Swap(SessionDeleted* other);

  // implements Message ----------------------------------------------

  SessionDeleted* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SessionDeleted& from);
  void MergeFrom(const SessionDeleted& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:protocol.SessionDeleted)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static SessionDeleted* default_instance_;
};
// -------------------------------------------------------------------

class Notification : public ::google::protobuf::Message {
 public:
  Notification();
  virtual ~Notification();

  Notification(const Notification& from);

  inline Notification& operator=(const Notification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Notification& default_instance();

  void Swap(Notification* other);

  // implements Message ----------------------------------------------

  Notification* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Notification& from);
  void MergeFrom(const Notification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 subscription_id = 1;
  inline bool has_subscription_id() const;
  inline void clear_subscription_id();
  static const int kSubscriptionIdFieldNumber = 1;
  inline ::google::protobuf::uint32 subscription_id() const;
  inline void set_subscription_id(::google::protobuf::uint32 value);

  // repeated .protocol.DataChange data_changes = 2;
  inline int data_changes_size() const;
  inline void clear_data_changes();
  static const int kDataChangesFieldNumber = 2;
  inline const ::protocol::DataChange& data_changes(int index) const;
  inline ::protocol::DataChange* mutable_data_changes(int index);
  inline ::protocol::DataChange* add_data_changes();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::DataChange >&
      data_changes() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::DataChange >*
      mutable_data_changes();

  // repeated .protocol.NodeId added_node_id = 3;
  inline int added_node_id_size() const;
  inline void clear_added_node_id();
  static const int kAddedNodeIdFieldNumber = 3;
  inline const ::protocol::NodeId& added_node_id(int index) const;
  inline ::protocol::NodeId* mutable_added_node_id(int index);
  inline ::protocol::NodeId* add_added_node_id();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >&
      added_node_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >*
      mutable_added_node_id();

  // repeated .protocol.NodeId deleted_node_id = 4;
  inline int deleted_node_id_size() const;
  inline void clear_deleted_node_id();
  static const int kDeletedNodeIdFieldNumber = 4;
  inline const ::protocol::NodeId& deleted_node_id(int index) const;
  inline ::protocol::NodeId* mutable_deleted_node_id(int index);
  inline ::protocol::NodeId* add_deleted_node_id();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >&
      deleted_node_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >*
      mutable_deleted_node_id();

  // repeated .protocol.NodeId semantics_changed_node_id = 5;
  inline int semantics_changed_node_id_size() const;
  inline void clear_semantics_changed_node_id();
  static const int kSemanticsChangedNodeIdFieldNumber = 5;
  inline const ::protocol::NodeId& semantics_changed_node_id(int index) const;
  inline ::protocol::NodeId* mutable_semantics_changed_node_id(int index);
  inline ::protocol::NodeId* add_semantics_changed_node_id();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >&
      semantics_changed_node_id() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >*
      mutable_semantics_changed_node_id();

  // repeated .protocol.Reference added_references = 6;
  inline int added_references_size() const;
  inline void clear_added_references();
  static const int kAddedReferencesFieldNumber = 6;
  inline const ::protocol::Reference& added_references(int index) const;
  inline ::protocol::Reference* mutable_added_references(int index);
  inline ::protocol::Reference* add_added_references();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Reference >&
      added_references() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Reference >*
      mutable_added_references();

  // repeated .protocol.Reference deleted_references = 7;
  inline int deleted_references_size() const;
  inline void clear_deleted_references();
  static const int kDeletedReferencesFieldNumber = 7;
  inline const ::protocol::Reference& deleted_references(int index) const;
  inline ::protocol::Reference* mutable_deleted_references(int index);
  inline ::protocol::Reference* add_deleted_references();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Reference >&
      deleted_references() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Reference >*
      mutable_deleted_references();

  // repeated .protocol.Event events = 8;
  inline int events_size() const;
  inline void clear_events();
  static const int kEventsFieldNumber = 8;
  inline const ::protocol::Event& events(int index) const;
  inline ::protocol::Event* mutable_events(int index);
  inline ::protocol::Event* add_events();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Event >&
      events() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Event >*
      mutable_events();

  // optional .protocol.SessionDeleted session_deleted = 9;
  inline bool has_session_deleted() const;
  inline void clear_session_deleted();
  static const int kSessionDeletedFieldNumber = 9;
  inline const ::protocol::SessionDeleted& session_deleted() const;
  inline ::protocol::SessionDeleted* mutable_session_deleted();
  inline ::protocol::SessionDeleted* release_session_deleted();
  inline void set_allocated_session_deleted(::protocol::SessionDeleted* session_deleted);

  // @@protoc_insertion_point(class_scope:protocol.Notification)
 private:
  inline void set_has_subscription_id();
  inline void clear_has_subscription_id();
  inline void set_has_session_deleted();
  inline void clear_has_session_deleted();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::DataChange > data_changes_;
  ::google::protobuf::RepeatedPtrField< ::protocol::NodeId > added_node_id_;
  ::google::protobuf::RepeatedPtrField< ::protocol::NodeId > deleted_node_id_;
  ::google::protobuf::RepeatedPtrField< ::protocol::NodeId > semantics_changed_node_id_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Reference > added_references_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Reference > deleted_references_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Event > events_;
  ::protocol::SessionDeleted* session_deleted_;
  ::google::protobuf::uint32 subscription_id_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Notification* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  Message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .protocol.Notification notifications = 1;
  inline int notifications_size() const;
  inline void clear_notifications();
  static const int kNotificationsFieldNumber = 1;
  inline const ::protocol::Notification& notifications(int index) const;
  inline ::protocol::Notification* mutable_notifications(int index);
  inline ::protocol::Notification* add_notifications();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Notification >&
      notifications() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Notification >*
      mutable_notifications();

  // repeated .protocol.Request requests = 2;
  inline int requests_size() const;
  inline void clear_requests();
  static const int kRequestsFieldNumber = 2;
  inline const ::protocol::Request& requests(int index) const;
  inline ::protocol::Request* mutable_requests(int index);
  inline ::protocol::Request* add_requests();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Request >&
      requests() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Request >*
      mutable_requests();

  // repeated .protocol.Response responses = 3;
  inline int responses_size() const;
  inline void clear_responses();
  static const int kResponsesFieldNumber = 3;
  inline const ::protocol::Response& responses(int index) const;
  inline ::protocol::Response* mutable_responses(int index);
  inline ::protocol::Response* add_responses();
  inline const ::google::protobuf::RepeatedPtrField< ::protocol::Response >&
      responses() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocol::Response >*
      mutable_responses();

  // @@protoc_insertion_point(class_scope:protocol.Message)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Notification > notifications_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Request > requests_;
  ::google::protobuf::RepeatedPtrField< ::protocol::Response > responses_;
  friend void  protobuf_AddDesc_scada_2eproto();
  friend void protobuf_AssignDesc_scada_2eproto();
  friend void protobuf_ShutdownFile_scada_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

// Attributes

// optional bytes browse_name = 3;
inline bool Attributes::has_browse_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Attributes::set_has_browse_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Attributes::clear_has_browse_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Attributes::clear_browse_name() {
  if (browse_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    browse_name_->clear();
  }
  clear_has_browse_name();
}
inline const ::std::string& Attributes::browse_name() const {
  // @@protoc_insertion_point(field_get:protocol.Attributes.browse_name)
  return *browse_name_;
}
inline void Attributes::set_browse_name(const ::std::string& value) {
  set_has_browse_name();
  if (browse_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    browse_name_ = new ::std::string;
  }
  browse_name_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Attributes.browse_name)
}
inline void Attributes::set_browse_name(const char* value) {
  set_has_browse_name();
  if (browse_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    browse_name_ = new ::std::string;
  }
  browse_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Attributes.browse_name)
}
inline void Attributes::set_browse_name(const void* value, size_t size) {
  set_has_browse_name();
  if (browse_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    browse_name_ = new ::std::string;
  }
  browse_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Attributes.browse_name)
}
inline ::std::string* Attributes::mutable_browse_name() {
  set_has_browse_name();
  if (browse_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    browse_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Attributes.browse_name)
  return browse_name_;
}
inline ::std::string* Attributes::release_browse_name() {
  clear_has_browse_name();
  if (browse_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = browse_name_;
    browse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Attributes::set_allocated_browse_name(::std::string* browse_name) {
  if (browse_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete browse_name_;
  }
  if (browse_name) {
    set_has_browse_name();
    browse_name_ = browse_name;
  } else {
    clear_has_browse_name();
    browse_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Attributes.browse_name)
}

// optional bytes display_name = 4;
inline bool Attributes::has_display_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Attributes::set_has_display_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Attributes::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Attributes::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& Attributes::display_name() const {
  // @@protoc_insertion_point(field_get:protocol.Attributes.display_name)
  return *display_name_;
}
inline void Attributes::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Attributes.display_name)
}
inline void Attributes::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Attributes.display_name)
}
inline void Attributes::set_display_name(const void* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Attributes.display_name)
}
inline ::std::string* Attributes::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    display_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Attributes.display_name)
  return display_name_;
}
inline ::std::string* Attributes::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Attributes::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Attributes.display_name)
}

// optional .protocol.Variant value = 13;
inline bool Attributes::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Attributes::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Attributes::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Attributes::clear_value() {
  if (value_ != NULL) value_->::protocol::Variant::Clear();
  clear_has_value();
}
inline const ::protocol::Variant& Attributes::value() const {
  // @@protoc_insertion_point(field_get:protocol.Attributes.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::protocol::Variant* Attributes::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::protocol::Variant;
  // @@protoc_insertion_point(field_mutable:protocol.Attributes.value)
  return value_;
}
inline ::protocol::Variant* Attributes::release_value() {
  clear_has_value();
  ::protocol::Variant* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Attributes::set_allocated_value(::protocol::Variant* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Attributes.value)
}

// optional .protocol.NodeId data_type_id = 14;
inline bool Attributes::has_data_type_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Attributes::set_has_data_type_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Attributes::clear_has_data_type_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Attributes::clear_data_type_id() {
  if (data_type_id_ != NULL) data_type_id_->::protocol::NodeId::Clear();
  clear_has_data_type_id();
}
inline const ::protocol::NodeId& Attributes::data_type_id() const {
  // @@protoc_insertion_point(field_get:protocol.Attributes.data_type_id)
  return data_type_id_ != NULL ? *data_type_id_ : *default_instance_->data_type_id_;
}
inline ::protocol::NodeId* Attributes::mutable_data_type_id() {
  set_has_data_type_id();
  if (data_type_id_ == NULL) data_type_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Attributes.data_type_id)
  return data_type_id_;
}
inline ::protocol::NodeId* Attributes::release_data_type_id() {
  clear_has_data_type_id();
  ::protocol::NodeId* temp = data_type_id_;
  data_type_id_ = NULL;
  return temp;
}
inline void Attributes::set_allocated_data_type_id(::protocol::NodeId* data_type_id) {
  delete data_type_id_;
  data_type_id_ = data_type_id;
  if (data_type_id) {
    set_has_data_type_id();
  } else {
    clear_has_data_type_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Attributes.data_type_id)
}

// -------------------------------------------------------------------

// Status

// required uint32 code = 1;
inline bool Status::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Status::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Status::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Status::clear_code() {
  code_ = 0u;
  clear_has_code();
}
inline ::google::protobuf::uint32 Status::code() const {
  // @@protoc_insertion_point(field_get:protocol.Status.code)
  return code_;
}
inline void Status::set_code(::google::protobuf::uint32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:protocol.Status.code)
}

// -------------------------------------------------------------------

// Qualifier

// required .protocol.Qualifier.Severity severity = 1;
inline bool Qualifier::has_severity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Qualifier::set_has_severity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Qualifier::clear_has_severity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Qualifier::clear_severity() {
  severity_ = 0;
  clear_has_severity();
}
inline ::protocol::Qualifier_Severity Qualifier::severity() const {
  // @@protoc_insertion_point(field_get:protocol.Qualifier.severity)
  return static_cast< ::protocol::Qualifier_Severity >(severity_);
}
inline void Qualifier::set_severity(::protocol::Qualifier_Severity value) {
  assert(::protocol::Qualifier_Severity_IsValid(value));
  set_has_severity();
  severity_ = value;
  // @@protoc_insertion_point(field_set:protocol.Qualifier.severity)
}

// optional .protocol.Qualifier.SubCode sub_code = 2;
inline bool Qualifier::has_sub_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Qualifier::set_has_sub_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Qualifier::clear_has_sub_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Qualifier::clear_sub_code() {
  sub_code_ = 0;
  clear_has_sub_code();
}
inline ::protocol::Qualifier_SubCode Qualifier::sub_code() const {
  // @@protoc_insertion_point(field_get:protocol.Qualifier.sub_code)
  return static_cast< ::protocol::Qualifier_SubCode >(sub_code_);
}
inline void Qualifier::set_sub_code(::protocol::Qualifier_SubCode value) {
  assert(::protocol::Qualifier_SubCode_IsValid(value));
  set_has_sub_code();
  sub_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.Qualifier.sub_code)
}

// optional .protocol.Qualifier.Limit limit = 3;
inline bool Qualifier::has_limit() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Qualifier::set_has_limit() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Qualifier::clear_has_limit() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Qualifier::clear_limit() {
  limit_ = 0;
  clear_has_limit();
}
inline ::protocol::Qualifier_Limit Qualifier::limit() const {
  // @@protoc_insertion_point(field_get:protocol.Qualifier.limit)
  return static_cast< ::protocol::Qualifier_Limit >(limit_);
}
inline void Qualifier::set_limit(::protocol::Qualifier_Limit value) {
  assert(::protocol::Qualifier_Limit_IsValid(value));
  set_has_limit();
  limit_ = value;
  // @@protoc_insertion_point(field_set:protocol.Qualifier.limit)
}

// -------------------------------------------------------------------

// NodeId

// optional uint32 namespace_index = 1;
inline bool NodeId::has_namespace_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeId::set_has_namespace_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeId::clear_has_namespace_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeId::clear_namespace_index() {
  namespace_index_ = 0u;
  clear_has_namespace_index();
}
inline ::google::protobuf::uint32 NodeId::namespace_index() const {
  // @@protoc_insertion_point(field_get:protocol.NodeId.namespace_index)
  return namespace_index_;
}
inline void NodeId::set_namespace_index(::google::protobuf::uint32 value) {
  set_has_namespace_index();
  namespace_index_ = value;
  // @@protoc_insertion_point(field_set:protocol.NodeId.namespace_index)
}

// optional uint32 numeric_id = 2;
inline bool NodeId::has_numeric_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeId::set_has_numeric_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeId::clear_has_numeric_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeId::clear_numeric_id() {
  numeric_id_ = 0u;
  clear_has_numeric_id();
}
inline ::google::protobuf::uint32 NodeId::numeric_id() const {
  // @@protoc_insertion_point(field_get:protocol.NodeId.numeric_id)
  return numeric_id_;
}
inline void NodeId::set_numeric_id(::google::protobuf::uint32 value) {
  set_has_numeric_id();
  numeric_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.NodeId.numeric_id)
}

// optional string string_id = 3;
inline bool NodeId::has_string_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeId::set_has_string_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeId::clear_has_string_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeId::clear_string_id() {
  if (string_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_id_->clear();
  }
  clear_has_string_id();
}
inline const ::std::string& NodeId::string_id() const {
  // @@protoc_insertion_point(field_get:protocol.NodeId.string_id)
  return *string_id_;
}
inline void NodeId::set_string_id(const ::std::string& value) {
  set_has_string_id();
  if (string_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_id_ = new ::std::string;
  }
  string_id_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.NodeId.string_id)
}
inline void NodeId::set_string_id(const char* value) {
  set_has_string_id();
  if (string_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_id_ = new ::std::string;
  }
  string_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.NodeId.string_id)
}
inline void NodeId::set_string_id(const char* value, size_t size) {
  set_has_string_id();
  if (string_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_id_ = new ::std::string;
  }
  string_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.NodeId.string_id)
}
inline ::std::string* NodeId::mutable_string_id() {
  set_has_string_id();
  if (string_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.NodeId.string_id)
  return string_id_;
}
inline ::std::string* NodeId::release_string_id() {
  clear_has_string_id();
  if (string_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = string_id_;
    string_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NodeId::set_allocated_string_id(::std::string* string_id) {
  if (string_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete string_id_;
  }
  if (string_id) {
    set_has_string_id();
    string_id_ = string_id;
  } else {
    clear_has_string_id();
    string_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeId.string_id)
}

// optional bytes opaque_id = 4;
inline bool NodeId::has_opaque_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeId::set_has_opaque_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeId::clear_has_opaque_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeId::clear_opaque_id() {
  if (opaque_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opaque_id_->clear();
  }
  clear_has_opaque_id();
}
inline const ::std::string& NodeId::opaque_id() const {
  // @@protoc_insertion_point(field_get:protocol.NodeId.opaque_id)
  return *opaque_id_;
}
inline void NodeId::set_opaque_id(const ::std::string& value) {
  set_has_opaque_id();
  if (opaque_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opaque_id_ = new ::std::string;
  }
  opaque_id_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.NodeId.opaque_id)
}
inline void NodeId::set_opaque_id(const char* value) {
  set_has_opaque_id();
  if (opaque_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opaque_id_ = new ::std::string;
  }
  opaque_id_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.NodeId.opaque_id)
}
inline void NodeId::set_opaque_id(const void* value, size_t size) {
  set_has_opaque_id();
  if (opaque_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opaque_id_ = new ::std::string;
  }
  opaque_id_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.NodeId.opaque_id)
}
inline ::std::string* NodeId::mutable_opaque_id() {
  set_has_opaque_id();
  if (opaque_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    opaque_id_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.NodeId.opaque_id)
  return opaque_id_;
}
inline ::std::string* NodeId::release_opaque_id() {
  clear_has_opaque_id();
  if (opaque_id_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = opaque_id_;
    opaque_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void NodeId::set_allocated_opaque_id(::std::string* opaque_id) {
  if (opaque_id_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete opaque_id_;
  }
  if (opaque_id) {
    set_has_opaque_id();
    opaque_id_ = opaque_id;
  } else {
    clear_has_opaque_id();
    opaque_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.NodeId.opaque_id)
}

// -------------------------------------------------------------------

// Variant

// optional bool bool_value = 1;
inline bool Variant::has_bool_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Variant::set_has_bool_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Variant::clear_has_bool_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Variant::clear_bool_value() {
  bool_value_ = false;
  clear_has_bool_value();
}
inline bool Variant::bool_value() const {
  // @@protoc_insertion_point(field_get:protocol.Variant.bool_value)
  return bool_value_;
}
inline void Variant::set_bool_value(bool value) {
  set_has_bool_value();
  bool_value_ = value;
  // @@protoc_insertion_point(field_set:protocol.Variant.bool_value)
}

// optional int32 int32_value = 2;
inline bool Variant::has_int32_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Variant::set_has_int32_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Variant::clear_has_int32_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Variant::clear_int32_value() {
  int32_value_ = 0;
  clear_has_int32_value();
}
inline ::google::protobuf::int32 Variant::int32_value() const {
  // @@protoc_insertion_point(field_get:protocol.Variant.int32_value)
  return int32_value_;
}
inline void Variant::set_int32_value(::google::protobuf::int32 value) {
  set_has_int32_value();
  int32_value_ = value;
  // @@protoc_insertion_point(field_set:protocol.Variant.int32_value)
}

// optional int64 int64_value = 3;
inline bool Variant::has_int64_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Variant::set_has_int64_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Variant::clear_has_int64_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Variant::clear_int64_value() {
  int64_value_ = GOOGLE_LONGLONG(0);
  clear_has_int64_value();
}
inline ::google::protobuf::int64 Variant::int64_value() const {
  // @@protoc_insertion_point(field_get:protocol.Variant.int64_value)
  return int64_value_;
}
inline void Variant::set_int64_value(::google::protobuf::int64 value) {
  set_has_int64_value();
  int64_value_ = value;
  // @@protoc_insertion_point(field_set:protocol.Variant.int64_value)
}

// optional double double_value = 4;
inline bool Variant::has_double_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Variant::set_has_double_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Variant::clear_has_double_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Variant::clear_double_value() {
  double_value_ = 0;
  clear_has_double_value();
}
inline double Variant::double_value() const {
  // @@protoc_insertion_point(field_get:protocol.Variant.double_value)
  return double_value_;
}
inline void Variant::set_double_value(double value) {
  set_has_double_value();
  double_value_ = value;
  // @@protoc_insertion_point(field_set:protocol.Variant.double_value)
}

// optional bytes string_value = 5;
inline bool Variant::has_string_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Variant::set_has_string_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Variant::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Variant::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& Variant::string_value() const {
  // @@protoc_insertion_point(field_get:protocol.Variant.string_value)
  return *string_value_;
}
inline void Variant::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Variant.string_value)
}
inline void Variant::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Variant.string_value)
}
inline void Variant::set_string_value(const void* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Variant.string_value)
}
inline ::std::string* Variant::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    string_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Variant.string_value)
  return string_value_;
}
inline ::std::string* Variant::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Variant::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Variant.string_value)
}

// optional .protocol.NodeId node_id_value = 6;
inline bool Variant::has_node_id_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Variant::set_has_node_id_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Variant::clear_has_node_id_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Variant::clear_node_id_value() {
  if (node_id_value_ != NULL) node_id_value_->::protocol::NodeId::Clear();
  clear_has_node_id_value();
}
inline const ::protocol::NodeId& Variant::node_id_value() const {
  // @@protoc_insertion_point(field_get:protocol.Variant.node_id_value)
  return node_id_value_ != NULL ? *node_id_value_ : *default_instance_->node_id_value_;
}
inline ::protocol::NodeId* Variant::mutable_node_id_value() {
  set_has_node_id_value();
  if (node_id_value_ == NULL) node_id_value_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Variant.node_id_value)
  return node_id_value_;
}
inline ::protocol::NodeId* Variant::release_node_id_value() {
  clear_has_node_id_value();
  ::protocol::NodeId* temp = node_id_value_;
  node_id_value_ = NULL;
  return temp;
}
inline void Variant::set_allocated_node_id_value(::protocol::NodeId* node_id_value) {
  delete node_id_value_;
  node_id_value_ = node_id_value;
  if (node_id_value) {
    set_has_node_id_value();
  } else {
    clear_has_node_id_value();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Variant.node_id_value)
}

// optional bytes localized_text_value = 7;
inline bool Variant::has_localized_text_value() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Variant::set_has_localized_text_value() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Variant::clear_has_localized_text_value() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Variant::clear_localized_text_value() {
  if (localized_text_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_text_value_->clear();
  }
  clear_has_localized_text_value();
}
inline const ::std::string& Variant::localized_text_value() const {
  // @@protoc_insertion_point(field_get:protocol.Variant.localized_text_value)
  return *localized_text_value_;
}
inline void Variant::set_localized_text_value(const ::std::string& value) {
  set_has_localized_text_value();
  if (localized_text_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_text_value_ = new ::std::string;
  }
  localized_text_value_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Variant.localized_text_value)
}
inline void Variant::set_localized_text_value(const char* value) {
  set_has_localized_text_value();
  if (localized_text_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_text_value_ = new ::std::string;
  }
  localized_text_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Variant.localized_text_value)
}
inline void Variant::set_localized_text_value(const void* value, size_t size) {
  set_has_localized_text_value();
  if (localized_text_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_text_value_ = new ::std::string;
  }
  localized_text_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Variant.localized_text_value)
}
inline ::std::string* Variant::mutable_localized_text_value() {
  set_has_localized_text_value();
  if (localized_text_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    localized_text_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Variant.localized_text_value)
  return localized_text_value_;
}
inline ::std::string* Variant::release_localized_text_value() {
  clear_has_localized_text_value();
  if (localized_text_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = localized_text_value_;
    localized_text_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Variant::set_allocated_localized_text_value(::std::string* localized_text_value) {
  if (localized_text_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete localized_text_value_;
  }
  if (localized_text_value) {
    set_has_localized_text_value();
    localized_text_value_ = localized_text_value;
  } else {
    clear_has_localized_text_value();
    localized_text_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Variant.localized_text_value)
}

// -------------------------------------------------------------------

// DataValue

// required uint64 server_timestamp = 1;
inline bool DataValue::has_server_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataValue::set_has_server_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataValue::clear_has_server_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataValue::clear_server_timestamp() {
  server_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_server_timestamp();
}
inline ::google::protobuf::uint64 DataValue::server_timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.DataValue.server_timestamp)
  return server_timestamp_;
}
inline void DataValue::set_server_timestamp(::google::protobuf::uint64 value) {
  set_has_server_timestamp();
  server_timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.DataValue.server_timestamp)
}

// optional uint64 source_timestamp = 2;
inline bool DataValue::has_source_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataValue::set_has_source_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataValue::clear_has_source_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataValue::clear_source_timestamp() {
  source_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_source_timestamp();
}
inline ::google::protobuf::uint64 DataValue::source_timestamp() const {
  // @@protoc_insertion_point(field_get:protocol.DataValue.source_timestamp)
  return source_timestamp_;
}
inline void DataValue::set_source_timestamp(::google::protobuf::uint64 value) {
  set_has_source_timestamp();
  source_timestamp_ = value;
  // @@protoc_insertion_point(field_set:protocol.DataValue.source_timestamp)
}

// optional .protocol.Variant value = 3;
inline bool DataValue::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataValue::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataValue::clear_value() {
  if (value_ != NULL) value_->::protocol::Variant::Clear();
  clear_has_value();
}
inline const ::protocol::Variant& DataValue::value() const {
  // @@protoc_insertion_point(field_get:protocol.DataValue.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::protocol::Variant* DataValue::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::protocol::Variant;
  // @@protoc_insertion_point(field_mutable:protocol.DataValue.value)
  return value_;
}
inline ::protocol::Variant* DataValue::release_value() {
  clear_has_value();
  ::protocol::Variant* temp = value_;
  value_ = NULL;
  return temp;
}
inline void DataValue::set_allocated_value(::protocol::Variant* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.DataValue.value)
}

// required uint32 qualifier = 4;
inline bool DataValue::has_qualifier() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataValue::set_has_qualifier() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataValue::clear_has_qualifier() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataValue::clear_qualifier() {
  qualifier_ = 0u;
  clear_has_qualifier();
}
inline ::google::protobuf::uint32 DataValue::qualifier() const {
  // @@protoc_insertion_point(field_get:protocol.DataValue.qualifier)
  return qualifier_;
}
inline void DataValue::set_qualifier(::google::protobuf::uint32 value) {
  set_has_qualifier();
  qualifier_ = value;
  // @@protoc_insertion_point(field_set:protocol.DataValue.qualifier)
}

// optional uint32 status_code = 5;
inline bool DataValue::has_status_code() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataValue::set_has_status_code() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataValue::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataValue::clear_status_code() {
  status_code_ = 0u;
  clear_has_status_code();
}
inline ::google::protobuf::uint32 DataValue::status_code() const {
  // @@protoc_insertion_point(field_get:protocol.DataValue.status_code)
  return status_code_;
}
inline void DataValue::set_status_code(::google::protobuf::uint32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.DataValue.status_code)
}

// -------------------------------------------------------------------

// Event

// optional uint32 monitored_item_id = 1;
inline bool Event::has_monitored_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Event::set_has_monitored_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Event::clear_has_monitored_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Event::clear_monitored_item_id() {
  monitored_item_id_ = 0u;
  clear_has_monitored_item_id();
}
inline ::google::protobuf::uint32 Event::monitored_item_id() const {
  // @@protoc_insertion_point(field_get:protocol.Event.monitored_item_id)
  return monitored_item_id_;
}
inline void Event::set_monitored_item_id(::google::protobuf::uint32 value) {
  set_has_monitored_item_id();
  monitored_item_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Event.monitored_item_id)
}

// required uint64 time = 2;
inline bool Event::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Event::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Event::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Event::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::uint64 Event::time() const {
  // @@protoc_insertion_point(field_get:protocol.Event.time)
  return time_;
}
inline void Event::set_time(::google::protobuf::uint64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Event.time)
}

// required uint32 severity = 3;
inline bool Event::has_severity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Event::set_has_severity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Event::clear_has_severity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Event::clear_severity() {
  severity_ = 0u;
  clear_has_severity();
}
inline ::google::protobuf::uint32 Event::severity() const {
  // @@protoc_insertion_point(field_get:protocol.Event.severity)
  return severity_;
}
inline void Event::set_severity(::google::protobuf::uint32 value) {
  set_has_severity();
  severity_ = value;
  // @@protoc_insertion_point(field_set:protocol.Event.severity)
}

// optional .protocol.NodeId source_node_id = 4;
inline bool Event::has_source_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Event::set_has_source_node_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Event::clear_has_source_node_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Event::clear_source_node_id() {
  if (source_node_id_ != NULL) source_node_id_->::protocol::NodeId::Clear();
  clear_has_source_node_id();
}
inline const ::protocol::NodeId& Event::source_node_id() const {
  // @@protoc_insertion_point(field_get:protocol.Event.source_node_id)
  return source_node_id_ != NULL ? *source_node_id_ : *default_instance_->source_node_id_;
}
inline ::protocol::NodeId* Event::mutable_source_node_id() {
  set_has_source_node_id();
  if (source_node_id_ == NULL) source_node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Event.source_node_id)
  return source_node_id_;
}
inline ::protocol::NodeId* Event::release_source_node_id() {
  clear_has_source_node_id();
  ::protocol::NodeId* temp = source_node_id_;
  source_node_id_ = NULL;
  return temp;
}
inline void Event::set_allocated_source_node_id(::protocol::NodeId* source_node_id) {
  delete source_node_id_;
  source_node_id_ = source_node_id;
  if (source_node_id) {
    set_has_source_node_id();
  } else {
    clear_has_source_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Event.source_node_id)
}

// optional .protocol.NodeId user_node_id = 5;
inline bool Event::has_user_node_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Event::set_has_user_node_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Event::clear_has_user_node_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Event::clear_user_node_id() {
  if (user_node_id_ != NULL) user_node_id_->::protocol::NodeId::Clear();
  clear_has_user_node_id();
}
inline const ::protocol::NodeId& Event::user_node_id() const {
  // @@protoc_insertion_point(field_get:protocol.Event.user_node_id)
  return user_node_id_ != NULL ? *user_node_id_ : *default_instance_->user_node_id_;
}
inline ::protocol::NodeId* Event::mutable_user_node_id() {
  set_has_user_node_id();
  if (user_node_id_ == NULL) user_node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Event.user_node_id)
  return user_node_id_;
}
inline ::protocol::NodeId* Event::release_user_node_id() {
  clear_has_user_node_id();
  ::protocol::NodeId* temp = user_node_id_;
  user_node_id_ = NULL;
  return temp;
}
inline void Event::set_allocated_user_node_id(::protocol::NodeId* user_node_id) {
  delete user_node_id_;
  user_node_id_ = user_node_id;
  if (user_node_id) {
    set_has_user_node_id();
  } else {
    clear_has_user_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Event.user_node_id)
}

// optional .protocol.Variant value = 6;
inline bool Event::has_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Event::set_has_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Event::clear_has_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Event::clear_value() {
  if (value_ != NULL) value_->::protocol::Variant::Clear();
  clear_has_value();
}
inline const ::protocol::Variant& Event::value() const {
  // @@protoc_insertion_point(field_get:protocol.Event.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
inline ::protocol::Variant* Event::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::protocol::Variant;
  // @@protoc_insertion_point(field_mutable:protocol.Event.value)
  return value_;
}
inline ::protocol::Variant* Event::release_value() {
  clear_has_value();
  ::protocol::Variant* temp = value_;
  value_ = NULL;
  return temp;
}
inline void Event::set_allocated_value(::protocol::Variant* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Event.value)
}

// optional uint32 qualifier = 7;
inline bool Event::has_qualifier() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Event::set_has_qualifier() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Event::clear_has_qualifier() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Event::clear_qualifier() {
  qualifier_ = 0u;
  clear_has_qualifier();
}
inline ::google::protobuf::uint32 Event::qualifier() const {
  // @@protoc_insertion_point(field_get:protocol.Event.qualifier)
  return qualifier_;
}
inline void Event::set_qualifier(::google::protobuf::uint32 value) {
  set_has_qualifier();
  qualifier_ = value;
  // @@protoc_insertion_point(field_set:protocol.Event.qualifier)
}

// optional bytes message = 8;
inline bool Event::has_message() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Event::set_has_message() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Event::clear_has_message() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Event::clear_message() {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& Event::message() const {
  // @@protoc_insertion_point(field_get:protocol.Event.message)
  return *message_;
}
inline void Event::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Event.message)
}
inline void Event::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Event.message)
}
inline void Event::set_message(const void* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Event.message)
}
inline ::std::string* Event::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Event.message)
  return message_;
}
inline ::std::string* Event::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Event::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Event.message)
}

// optional bool acknowledged = 9;
inline bool Event::has_acknowledged() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Event::set_has_acknowledged() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Event::clear_has_acknowledged() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Event::clear_acknowledged() {
  acknowledged_ = false;
  clear_has_acknowledged();
}
inline bool Event::acknowledged() const {
  // @@protoc_insertion_point(field_get:protocol.Event.acknowledged)
  return acknowledged_;
}
inline void Event::set_acknowledged(bool value) {
  set_has_acknowledged();
  acknowledged_ = value;
  // @@protoc_insertion_point(field_set:protocol.Event.acknowledged)
}

// optional uint64 acknowledge_id = 10;
inline bool Event::has_acknowledge_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Event::set_has_acknowledge_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Event::clear_has_acknowledge_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Event::clear_acknowledge_id() {
  acknowledge_id_ = GOOGLE_ULONGLONG(0);
  clear_has_acknowledge_id();
}
inline ::google::protobuf::uint64 Event::acknowledge_id() const {
  // @@protoc_insertion_point(field_get:protocol.Event.acknowledge_id)
  return acknowledge_id_;
}
inline void Event::set_acknowledge_id(::google::protobuf::uint64 value) {
  set_has_acknowledge_id();
  acknowledge_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Event.acknowledge_id)
}

// optional uint64 acknowledge_time = 11;
inline bool Event::has_acknowledge_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Event::set_has_acknowledge_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Event::clear_has_acknowledge_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Event::clear_acknowledge_time() {
  acknowledge_time_ = GOOGLE_ULONGLONG(0);
  clear_has_acknowledge_time();
}
inline ::google::protobuf::uint64 Event::acknowledge_time() const {
  // @@protoc_insertion_point(field_get:protocol.Event.acknowledge_time)
  return acknowledge_time_;
}
inline void Event::set_acknowledge_time(::google::protobuf::uint64 value) {
  set_has_acknowledge_time();
  acknowledge_time_ = value;
  // @@protoc_insertion_point(field_set:protocol.Event.acknowledge_time)
}

// optional .protocol.NodeId acknowledge_user_id = 12;
inline bool Event::has_acknowledge_user_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Event::set_has_acknowledge_user_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Event::clear_has_acknowledge_user_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Event::clear_acknowledge_user_id() {
  if (acknowledge_user_id_ != NULL) acknowledge_user_id_->::protocol::NodeId::Clear();
  clear_has_acknowledge_user_id();
}
inline const ::protocol::NodeId& Event::acknowledge_user_id() const {
  // @@protoc_insertion_point(field_get:protocol.Event.acknowledge_user_id)
  return acknowledge_user_id_ != NULL ? *acknowledge_user_id_ : *default_instance_->acknowledge_user_id_;
}
inline ::protocol::NodeId* Event::mutable_acknowledge_user_id() {
  set_has_acknowledge_user_id();
  if (acknowledge_user_id_ == NULL) acknowledge_user_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Event.acknowledge_user_id)
  return acknowledge_user_id_;
}
inline ::protocol::NodeId* Event::release_acknowledge_user_id() {
  clear_has_acknowledge_user_id();
  ::protocol::NodeId* temp = acknowledge_user_id_;
  acknowledge_user_id_ = NULL;
  return temp;
}
inline void Event::set_allocated_acknowledge_user_id(::protocol::NodeId* acknowledge_user_id) {
  delete acknowledge_user_id_;
  acknowledge_user_id_ = acknowledge_user_id;
  if (acknowledge_user_id) {
    set_has_acknowledge_user_id();
  } else {
    clear_has_acknowledge_user_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Event.acknowledge_user_id)
}

// -------------------------------------------------------------------

// CreateSession

// required bytes user_name = 1;
inline bool CreateSession::has_user_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSession::set_has_user_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSession::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSession::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& CreateSession::user_name() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSession.user_name)
  return *user_name_;
}
inline void CreateSession::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.CreateSession.user_name)
}
inline void CreateSession::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.CreateSession.user_name)
}
inline void CreateSession::set_user_name(const void* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.CreateSession.user_name)
}
inline ::std::string* CreateSession::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.CreateSession.user_name)
  return user_name_;
}
inline ::std::string* CreateSession::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateSession::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateSession.user_name)
}

// optional bytes password = 2;
inline bool CreateSession::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSession::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSession::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSession::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CreateSession::password() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSession.password)
  return *password_;
}
inline void CreateSession::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.CreateSession.password)
}
inline void CreateSession::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.CreateSession.password)
}
inline void CreateSession::set_password(const void* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.CreateSession.password)
}
inline ::std::string* CreateSession::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.CreateSession.password)
  return password_;
}
inline ::std::string* CreateSession::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateSession::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateSession.password)
}

// optional bool delete_existing = 3;
inline bool CreateSession::has_delete_existing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateSession::set_has_delete_existing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateSession::clear_has_delete_existing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateSession::clear_delete_existing() {
  delete_existing_ = false;
  clear_has_delete_existing();
}
inline bool CreateSession::delete_existing() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSession.delete_existing)
  return delete_existing_;
}
inline void CreateSession::set_delete_existing(bool value) {
  set_has_delete_existing();
  delete_existing_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateSession.delete_existing)
}

// required uint32 protocol_version_major = 4;
inline bool CreateSession::has_protocol_version_major() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateSession::set_has_protocol_version_major() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateSession::clear_has_protocol_version_major() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateSession::clear_protocol_version_major() {
  protocol_version_major_ = 0u;
  clear_has_protocol_version_major();
}
inline ::google::protobuf::uint32 CreateSession::protocol_version_major() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSession.protocol_version_major)
  return protocol_version_major_;
}
inline void CreateSession::set_protocol_version_major(::google::protobuf::uint32 value) {
  set_has_protocol_version_major();
  protocol_version_major_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateSession.protocol_version_major)
}

// required uint32 protocol_version_minor = 5;
inline bool CreateSession::has_protocol_version_minor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateSession::set_has_protocol_version_minor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateSession::clear_has_protocol_version_minor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateSession::clear_protocol_version_minor() {
  protocol_version_minor_ = 0u;
  clear_has_protocol_version_minor();
}
inline ::google::protobuf::uint32 CreateSession::protocol_version_minor() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSession.protocol_version_minor)
  return protocol_version_minor_;
}
inline void CreateSession::set_protocol_version_minor(::google::protobuf::uint32 value) {
  set_has_protocol_version_minor();
  protocol_version_minor_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateSession.protocol_version_minor)
}

// -------------------------------------------------------------------

// CreateSessionResult

// optional string token = 1;
inline bool CreateSessionResult::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSessionResult::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSessionResult::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSessionResult::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CreateSessionResult::token() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSessionResult.token)
  return *token_;
}
inline void CreateSessionResult::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.CreateSessionResult.token)
}
inline void CreateSessionResult::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.CreateSessionResult.token)
}
inline void CreateSessionResult::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.CreateSessionResult.token)
}
inline ::std::string* CreateSessionResult::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.CreateSessionResult.token)
  return token_;
}
inline ::std::string* CreateSessionResult::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateSessionResult::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateSessionResult.token)
}

// optional .protocol.NodeId user_node_id = 2;
inline bool CreateSessionResult::has_user_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSessionResult::set_has_user_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSessionResult::clear_has_user_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSessionResult::clear_user_node_id() {
  if (user_node_id_ != NULL) user_node_id_->::protocol::NodeId::Clear();
  clear_has_user_node_id();
}
inline const ::protocol::NodeId& CreateSessionResult::user_node_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSessionResult.user_node_id)
  return user_node_id_ != NULL ? *user_node_id_ : *default_instance_->user_node_id_;
}
inline ::protocol::NodeId* CreateSessionResult::mutable_user_node_id() {
  set_has_user_node_id();
  if (user_node_id_ == NULL) user_node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.CreateSessionResult.user_node_id)
  return user_node_id_;
}
inline ::protocol::NodeId* CreateSessionResult::release_user_node_id() {
  clear_has_user_node_id();
  ::protocol::NodeId* temp = user_node_id_;
  user_node_id_ = NULL;
  return temp;
}
inline void CreateSessionResult::set_allocated_user_node_id(::protocol::NodeId* user_node_id) {
  delete user_node_id_;
  user_node_id_ = user_node_id;
  if (user_node_id) {
    set_has_user_node_id();
  } else {
    clear_has_user_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateSessionResult.user_node_id)
}

// optional uint32 user_rights = 3;
inline bool CreateSessionResult::has_user_rights() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateSessionResult::set_has_user_rights() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateSessionResult::clear_has_user_rights() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateSessionResult::clear_user_rights() {
  user_rights_ = 0u;
  clear_has_user_rights();
}
inline ::google::protobuf::uint32 CreateSessionResult::user_rights() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSessionResult.user_rights)
  return user_rights_;
}
inline void CreateSessionResult::set_user_rights(::google::protobuf::uint32 value) {
  set_has_user_rights();
  user_rights_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateSessionResult.user_rights)
}

// required uint32 protocol_version_major = 4;
inline bool CreateSessionResult::has_protocol_version_major() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateSessionResult::set_has_protocol_version_major() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateSessionResult::clear_has_protocol_version_major() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateSessionResult::clear_protocol_version_major() {
  protocol_version_major_ = 0u;
  clear_has_protocol_version_major();
}
inline ::google::protobuf::uint32 CreateSessionResult::protocol_version_major() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSessionResult.protocol_version_major)
  return protocol_version_major_;
}
inline void CreateSessionResult::set_protocol_version_major(::google::protobuf::uint32 value) {
  set_has_protocol_version_major();
  protocol_version_major_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateSessionResult.protocol_version_major)
}

// required uint32 protocol_version_minor = 5;
inline bool CreateSessionResult::has_protocol_version_minor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateSessionResult::set_has_protocol_version_minor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateSessionResult::clear_has_protocol_version_minor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateSessionResult::clear_protocol_version_minor() {
  protocol_version_minor_ = 0u;
  clear_has_protocol_version_minor();
}
inline ::google::protobuf::uint32 CreateSessionResult::protocol_version_minor() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSessionResult.protocol_version_minor)
  return protocol_version_minor_;
}
inline void CreateSessionResult::set_protocol_version_minor(::google::protobuf::uint32 value) {
  set_has_protocol_version_minor();
  protocol_version_minor_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateSessionResult.protocol_version_minor)
}

// -------------------------------------------------------------------

// DeleteSession

// optional string token = 1;
inline bool DeleteSession::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteSession::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteSession::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteSession::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& DeleteSession::token() const {
  // @@protoc_insertion_point(field_get:protocol.DeleteSession.token)
  return *token_;
}
inline void DeleteSession::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.DeleteSession.token)
}
inline void DeleteSession::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.DeleteSession.token)
}
inline void DeleteSession::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.DeleteSession.token)
}
inline ::std::string* DeleteSession::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    token_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.DeleteSession.token)
  return token_;
}
inline ::std::string* DeleteSession::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeleteSession::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.DeleteSession.token)
}

// -------------------------------------------------------------------

// Node

// required .protocol.NodeId node_id = 1;
inline bool Node::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Node::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Node::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Node::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& Node::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.Node.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* Node::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Node.node_id)
  return node_id_;
}
inline ::protocol::NodeId* Node::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void Node::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Node.node_id)
}

// optional .protocol.NodeId type_id = 2;
inline bool Node::has_type_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Node::set_has_type_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Node::clear_has_type_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Node::clear_type_id() {
  if (type_id_ != NULL) type_id_->::protocol::NodeId::Clear();
  clear_has_type_id();
}
inline const ::protocol::NodeId& Node::type_id() const {
  // @@protoc_insertion_point(field_get:protocol.Node.type_id)
  return type_id_ != NULL ? *type_id_ : *default_instance_->type_id_;
}
inline ::protocol::NodeId* Node::mutable_type_id() {
  set_has_type_id();
  if (type_id_ == NULL) type_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Node.type_id)
  return type_id_;
}
inline ::protocol::NodeId* Node::release_type_id() {
  clear_has_type_id();
  ::protocol::NodeId* temp = type_id_;
  type_id_ = NULL;
  return temp;
}
inline void Node::set_allocated_type_id(::protocol::NodeId* type_id) {
  delete type_id_;
  type_id_ = type_id;
  if (type_id) {
    set_has_type_id();
  } else {
    clear_has_type_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Node.type_id)
}

// optional .protocol.NodeClass node_class = 3;
inline bool Node::has_node_class() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Node::set_has_node_class() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Node::clear_has_node_class() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Node::clear_node_class() {
  node_class_ = 1;
  clear_has_node_class();
}
inline ::protocol::NodeClass Node::node_class() const {
  // @@protoc_insertion_point(field_get:protocol.Node.node_class)
  return static_cast< ::protocol::NodeClass >(node_class_);
}
inline void Node::set_node_class(::protocol::NodeClass value) {
  assert(::protocol::NodeClass_IsValid(value));
  set_has_node_class();
  node_class_ = value;
  // @@protoc_insertion_point(field_set:protocol.Node.node_class)
}

// optional .protocol.Attributes attributes = 5;
inline bool Node::has_attributes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Node::set_has_attributes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Node::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Node::clear_attributes() {
  if (attributes_ != NULL) attributes_->::protocol::Attributes::Clear();
  clear_has_attributes();
}
inline const ::protocol::Attributes& Node::attributes() const {
  // @@protoc_insertion_point(field_get:protocol.Node.attributes)
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::protocol::Attributes* Node::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::protocol::Attributes;
  // @@protoc_insertion_point(field_mutable:protocol.Node.attributes)
  return attributes_;
}
inline ::protocol::Attributes* Node::release_attributes() {
  clear_has_attributes();
  ::protocol::Attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline void Node::set_allocated_attributes(::protocol::Attributes* attributes) {
  delete attributes_;
  attributes_ = attributes;
  if (attributes) {
    set_has_attributes();
  } else {
    clear_has_attributes();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Node.attributes)
}

// optional .protocol.NodeId parent_id = 6;
inline bool Node::has_parent_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Node::set_has_parent_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Node::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Node::clear_parent_id() {
  if (parent_id_ != NULL) parent_id_->::protocol::NodeId::Clear();
  clear_has_parent_id();
}
inline const ::protocol::NodeId& Node::parent_id() const {
  // @@protoc_insertion_point(field_get:protocol.Node.parent_id)
  return parent_id_ != NULL ? *parent_id_ : *default_instance_->parent_id_;
}
inline ::protocol::NodeId* Node::mutable_parent_id() {
  set_has_parent_id();
  if (parent_id_ == NULL) parent_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Node.parent_id)
  return parent_id_;
}
inline ::protocol::NodeId* Node::release_parent_id() {
  clear_has_parent_id();
  ::protocol::NodeId* temp = parent_id_;
  parent_id_ = NULL;
  return temp;
}
inline void Node::set_allocated_parent_id(::protocol::NodeId* parent_id) {
  delete parent_id_;
  parent_id_ = parent_id;
  if (parent_id) {
    set_has_parent_id();
  } else {
    clear_has_parent_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Node.parent_id)
}

// optional .protocol.NodeId reference_type_id = 7;
inline bool Node::has_reference_type_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Node::set_has_reference_type_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Node::clear_has_reference_type_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Node::clear_reference_type_id() {
  if (reference_type_id_ != NULL) reference_type_id_->::protocol::NodeId::Clear();
  clear_has_reference_type_id();
}
inline const ::protocol::NodeId& Node::reference_type_id() const {
  // @@protoc_insertion_point(field_get:protocol.Node.reference_type_id)
  return reference_type_id_ != NULL ? *reference_type_id_ : *default_instance_->reference_type_id_;
}
inline ::protocol::NodeId* Node::mutable_reference_type_id() {
  set_has_reference_type_id();
  if (reference_type_id_ == NULL) reference_type_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Node.reference_type_id)
  return reference_type_id_;
}
inline ::protocol::NodeId* Node::release_reference_type_id() {
  clear_has_reference_type_id();
  ::protocol::NodeId* temp = reference_type_id_;
  reference_type_id_ = NULL;
  return temp;
}
inline void Node::set_allocated_reference_type_id(::protocol::NodeId* reference_type_id) {
  delete reference_type_id_;
  reference_type_id_ = reference_type_id;
  if (reference_type_id) {
    set_has_reference_type_id();
  } else {
    clear_has_reference_type_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Node.reference_type_id)
}

// -------------------------------------------------------------------

// CreateNode

// optional .protocol.NodeId requested_node_id = 1;
inline bool CreateNode::has_requested_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateNode::set_has_requested_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateNode::clear_has_requested_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateNode::clear_requested_node_id() {
  if (requested_node_id_ != NULL) requested_node_id_->::protocol::NodeId::Clear();
  clear_has_requested_node_id();
}
inline const ::protocol::NodeId& CreateNode::requested_node_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateNode.requested_node_id)
  return requested_node_id_ != NULL ? *requested_node_id_ : *default_instance_->requested_node_id_;
}
inline ::protocol::NodeId* CreateNode::mutable_requested_node_id() {
  set_has_requested_node_id();
  if (requested_node_id_ == NULL) requested_node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.CreateNode.requested_node_id)
  return requested_node_id_;
}
inline ::protocol::NodeId* CreateNode::release_requested_node_id() {
  clear_has_requested_node_id();
  ::protocol::NodeId* temp = requested_node_id_;
  requested_node_id_ = NULL;
  return temp;
}
inline void CreateNode::set_allocated_requested_node_id(::protocol::NodeId* requested_node_id) {
  delete requested_node_id_;
  requested_node_id_ = requested_node_id;
  if (requested_node_id) {
    set_has_requested_node_id();
  } else {
    clear_has_requested_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateNode.requested_node_id)
}

// required .protocol.NodeId type_id = 2;
inline bool CreateNode::has_type_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateNode::set_has_type_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateNode::clear_has_type_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateNode::clear_type_id() {
  if (type_id_ != NULL) type_id_->::protocol::NodeId::Clear();
  clear_has_type_id();
}
inline const ::protocol::NodeId& CreateNode::type_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateNode.type_id)
  return type_id_ != NULL ? *type_id_ : *default_instance_->type_id_;
}
inline ::protocol::NodeId* CreateNode::mutable_type_id() {
  set_has_type_id();
  if (type_id_ == NULL) type_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.CreateNode.type_id)
  return type_id_;
}
inline ::protocol::NodeId* CreateNode::release_type_id() {
  clear_has_type_id();
  ::protocol::NodeId* temp = type_id_;
  type_id_ = NULL;
  return temp;
}
inline void CreateNode::set_allocated_type_id(::protocol::NodeId* type_id) {
  delete type_id_;
  type_id_ = type_id;
  if (type_id) {
    set_has_type_id();
  } else {
    clear_has_type_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateNode.type_id)
}

// required .protocol.NodeId parent_id = 3;
inline bool CreateNode::has_parent_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateNode::set_has_parent_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateNode::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateNode::clear_parent_id() {
  if (parent_id_ != NULL) parent_id_->::protocol::NodeId::Clear();
  clear_has_parent_id();
}
inline const ::protocol::NodeId& CreateNode::parent_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateNode.parent_id)
  return parent_id_ != NULL ? *parent_id_ : *default_instance_->parent_id_;
}
inline ::protocol::NodeId* CreateNode::mutable_parent_id() {
  set_has_parent_id();
  if (parent_id_ == NULL) parent_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.CreateNode.parent_id)
  return parent_id_;
}
inline ::protocol::NodeId* CreateNode::release_parent_id() {
  clear_has_parent_id();
  ::protocol::NodeId* temp = parent_id_;
  parent_id_ = NULL;
  return temp;
}
inline void CreateNode::set_allocated_parent_id(::protocol::NodeId* parent_id) {
  delete parent_id_;
  parent_id_ = parent_id;
  if (parent_id) {
    set_has_parent_id();
  } else {
    clear_has_parent_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateNode.parent_id)
}

// required .protocol.NodeClass node_class = 5;
inline bool CreateNode::has_node_class() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateNode::set_has_node_class() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateNode::clear_has_node_class() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateNode::clear_node_class() {
  node_class_ = 1;
  clear_has_node_class();
}
inline ::protocol::NodeClass CreateNode::node_class() const {
  // @@protoc_insertion_point(field_get:protocol.CreateNode.node_class)
  return static_cast< ::protocol::NodeClass >(node_class_);
}
inline void CreateNode::set_node_class(::protocol::NodeClass value) {
  assert(::protocol::NodeClass_IsValid(value));
  set_has_node_class();
  node_class_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateNode.node_class)
}

// optional .protocol.Attributes attributes = 6;
inline bool CreateNode::has_attributes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateNode::set_has_attributes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateNode::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateNode::clear_attributes() {
  if (attributes_ != NULL) attributes_->::protocol::Attributes::Clear();
  clear_has_attributes();
}
inline const ::protocol::Attributes& CreateNode::attributes() const {
  // @@protoc_insertion_point(field_get:protocol.CreateNode.attributes)
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::protocol::Attributes* CreateNode::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::protocol::Attributes;
  // @@protoc_insertion_point(field_mutable:protocol.CreateNode.attributes)
  return attributes_;
}
inline ::protocol::Attributes* CreateNode::release_attributes() {
  clear_has_attributes();
  ::protocol::Attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline void CreateNode::set_allocated_attributes(::protocol::Attributes* attributes) {
  delete attributes_;
  attributes_ = attributes;
  if (attributes) {
    set_has_attributes();
  } else {
    clear_has_attributes();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateNode.attributes)
}

// -------------------------------------------------------------------

// CreateNodeResult

// required .protocol.NodeId node_id = 1;
inline bool CreateNodeResult::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateNodeResult::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateNodeResult::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateNodeResult::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& CreateNodeResult::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateNodeResult.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* CreateNodeResult::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.CreateNodeResult.node_id)
  return node_id_;
}
inline ::protocol::NodeId* CreateNodeResult::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void CreateNodeResult::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateNodeResult.node_id)
}

// -------------------------------------------------------------------

// DeleteNode

// required .protocol.NodeId node_id = 2;
inline bool DeleteNode::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteNode::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteNode::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteNode::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& DeleteNode::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.DeleteNode.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* DeleteNode::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.DeleteNode.node_id)
  return node_id_;
}
inline ::protocol::NodeId* DeleteNode::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void DeleteNode::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.DeleteNode.node_id)
}

// optional bool return_references = 10;
inline bool DeleteNode::has_return_references() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteNode::set_has_return_references() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteNode::clear_has_return_references() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteNode::clear_return_references() {
  return_references_ = false;
  clear_has_return_references();
}
inline bool DeleteNode::return_references() const {
  // @@protoc_insertion_point(field_get:protocol.DeleteNode.return_references)
  return return_references_;
}
inline void DeleteNode::set_return_references(bool value) {
  set_has_return_references();
  return_references_ = value;
  // @@protoc_insertion_point(field_set:protocol.DeleteNode.return_references)
}

// -------------------------------------------------------------------

// DeleteNodeResult

// repeated .protocol.NodeId references = 1;
inline int DeleteNodeResult::references_size() const {
  return references_.size();
}
inline void DeleteNodeResult::clear_references() {
  references_.Clear();
}
inline const ::protocol::NodeId& DeleteNodeResult::references(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DeleteNodeResult.references)
  return references_.Get(index);
}
inline ::protocol::NodeId* DeleteNodeResult::mutable_references(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DeleteNodeResult.references)
  return references_.Mutable(index);
}
inline ::protocol::NodeId* DeleteNodeResult::add_references() {
  // @@protoc_insertion_point(field_add:protocol.DeleteNodeResult.references)
  return references_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >&
DeleteNodeResult::references() const {
  // @@protoc_insertion_point(field_list:protocol.DeleteNodeResult.references)
  return references_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >*
DeleteNodeResult::mutable_references() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DeleteNodeResult.references)
  return &references_;
}

// -------------------------------------------------------------------

// ModifyNode

// required .protocol.NodeId node_id = 1;
inline bool ModifyNode::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyNode::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyNode::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyNode::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& ModifyNode::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.ModifyNode.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* ModifyNode::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.ModifyNode.node_id)
  return node_id_;
}
inline ::protocol::NodeId* ModifyNode::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void ModifyNode::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ModifyNode.node_id)
}

// optional .protocol.Attributes attributes = 2;
inline bool ModifyNode::has_attributes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyNode::set_has_attributes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyNode::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyNode::clear_attributes() {
  if (attributes_ != NULL) attributes_->::protocol::Attributes::Clear();
  clear_has_attributes();
}
inline const ::protocol::Attributes& ModifyNode::attributes() const {
  // @@protoc_insertion_point(field_get:protocol.ModifyNode.attributes)
  return attributes_ != NULL ? *attributes_ : *default_instance_->attributes_;
}
inline ::protocol::Attributes* ModifyNode::mutable_attributes() {
  set_has_attributes();
  if (attributes_ == NULL) attributes_ = new ::protocol::Attributes;
  // @@protoc_insertion_point(field_mutable:protocol.ModifyNode.attributes)
  return attributes_;
}
inline ::protocol::Attributes* ModifyNode::release_attributes() {
  clear_has_attributes();
  ::protocol::Attributes* temp = attributes_;
  attributes_ = NULL;
  return temp;
}
inline void ModifyNode::set_allocated_attributes(::protocol::Attributes* attributes) {
  delete attributes_;
  attributes_ = attributes;
  if (attributes) {
    set_has_attributes();
  } else {
    clear_has_attributes();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ModifyNode.attributes)
}

// -------------------------------------------------------------------

// Reference

// required .protocol.NodeId reference_type_id = 1;
inline bool Reference::has_reference_type_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Reference::set_has_reference_type_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Reference::clear_has_reference_type_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Reference::clear_reference_type_id() {
  if (reference_type_id_ != NULL) reference_type_id_->::protocol::NodeId::Clear();
  clear_has_reference_type_id();
}
inline const ::protocol::NodeId& Reference::reference_type_id() const {
  // @@protoc_insertion_point(field_get:protocol.Reference.reference_type_id)
  return reference_type_id_ != NULL ? *reference_type_id_ : *default_instance_->reference_type_id_;
}
inline ::protocol::NodeId* Reference::mutable_reference_type_id() {
  set_has_reference_type_id();
  if (reference_type_id_ == NULL) reference_type_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Reference.reference_type_id)
  return reference_type_id_;
}
inline ::protocol::NodeId* Reference::release_reference_type_id() {
  clear_has_reference_type_id();
  ::protocol::NodeId* temp = reference_type_id_;
  reference_type_id_ = NULL;
  return temp;
}
inline void Reference::set_allocated_reference_type_id(::protocol::NodeId* reference_type_id) {
  delete reference_type_id_;
  reference_type_id_ = reference_type_id;
  if (reference_type_id) {
    set_has_reference_type_id();
  } else {
    clear_has_reference_type_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Reference.reference_type_id)
}

// required .protocol.NodeId source_id = 2;
inline bool Reference::has_source_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Reference::set_has_source_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Reference::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Reference::clear_source_id() {
  if (source_id_ != NULL) source_id_->::protocol::NodeId::Clear();
  clear_has_source_id();
}
inline const ::protocol::NodeId& Reference::source_id() const {
  // @@protoc_insertion_point(field_get:protocol.Reference.source_id)
  return source_id_ != NULL ? *source_id_ : *default_instance_->source_id_;
}
inline ::protocol::NodeId* Reference::mutable_source_id() {
  set_has_source_id();
  if (source_id_ == NULL) source_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Reference.source_id)
  return source_id_;
}
inline ::protocol::NodeId* Reference::release_source_id() {
  clear_has_source_id();
  ::protocol::NodeId* temp = source_id_;
  source_id_ = NULL;
  return temp;
}
inline void Reference::set_allocated_source_id(::protocol::NodeId* source_id) {
  delete source_id_;
  source_id_ = source_id;
  if (source_id) {
    set_has_source_id();
  } else {
    clear_has_source_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Reference.source_id)
}

// required .protocol.NodeId target_id = 3;
inline bool Reference::has_target_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Reference::set_has_target_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Reference::clear_has_target_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Reference::clear_target_id() {
  if (target_id_ != NULL) target_id_->::protocol::NodeId::Clear();
  clear_has_target_id();
}
inline const ::protocol::NodeId& Reference::target_id() const {
  // @@protoc_insertion_point(field_get:protocol.Reference.target_id)
  return target_id_ != NULL ? *target_id_ : *default_instance_->target_id_;
}
inline ::protocol::NodeId* Reference::mutable_target_id() {
  set_has_target_id();
  if (target_id_ == NULL) target_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Reference.target_id)
  return target_id_;
}
inline ::protocol::NodeId* Reference::release_target_id() {
  clear_has_target_id();
  ::protocol::NodeId* temp = target_id_;
  target_id_ = NULL;
  return temp;
}
inline void Reference::set_allocated_target_id(::protocol::NodeId* target_id) {
  delete target_id_;
  target_id_ = target_id;
  if (target_id) {
    set_has_target_id();
  } else {
    clear_has_target_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Reference.target_id)
}

// -------------------------------------------------------------------

// ChangePassword

// required .protocol.NodeId user_node_id = 1;
inline bool ChangePassword::has_user_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangePassword::set_has_user_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangePassword::clear_has_user_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangePassword::clear_user_node_id() {
  if (user_node_id_ != NULL) user_node_id_->::protocol::NodeId::Clear();
  clear_has_user_node_id();
}
inline const ::protocol::NodeId& ChangePassword::user_node_id() const {
  // @@protoc_insertion_point(field_get:protocol.ChangePassword.user_node_id)
  return user_node_id_ != NULL ? *user_node_id_ : *default_instance_->user_node_id_;
}
inline ::protocol::NodeId* ChangePassword::mutable_user_node_id() {
  set_has_user_node_id();
  if (user_node_id_ == NULL) user_node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.ChangePassword.user_node_id)
  return user_node_id_;
}
inline ::protocol::NodeId* ChangePassword::release_user_node_id() {
  clear_has_user_node_id();
  ::protocol::NodeId* temp = user_node_id_;
  user_node_id_ = NULL;
  return temp;
}
inline void ChangePassword::set_allocated_user_node_id(::protocol::NodeId* user_node_id) {
  delete user_node_id_;
  user_node_id_ = user_node_id;
  if (user_node_id) {
    set_has_user_node_id();
  } else {
    clear_has_user_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ChangePassword.user_node_id)
}

// required bytes current_password = 2;
inline bool ChangePassword::has_current_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangePassword::set_has_current_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangePassword::clear_has_current_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangePassword::clear_current_password() {
  if (current_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_password_->clear();
  }
  clear_has_current_password();
}
inline const ::std::string& ChangePassword::current_password() const {
  // @@protoc_insertion_point(field_get:protocol.ChangePassword.current_password)
  return *current_password_;
}
inline void ChangePassword::set_current_password(const ::std::string& value) {
  set_has_current_password();
  if (current_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_password_ = new ::std::string;
  }
  current_password_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.ChangePassword.current_password)
}
inline void ChangePassword::set_current_password(const char* value) {
  set_has_current_password();
  if (current_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_password_ = new ::std::string;
  }
  current_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.ChangePassword.current_password)
}
inline void ChangePassword::set_current_password(const void* value, size_t size) {
  set_has_current_password();
  if (current_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_password_ = new ::std::string;
  }
  current_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.ChangePassword.current_password)
}
inline ::std::string* ChangePassword::mutable_current_password() {
  set_has_current_password();
  if (current_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    current_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ChangePassword.current_password)
  return current_password_;
}
inline ::std::string* ChangePassword::release_current_password() {
  clear_has_current_password();
  if (current_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = current_password_;
    current_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChangePassword::set_allocated_current_password(::std::string* current_password) {
  if (current_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete current_password_;
  }
  if (current_password) {
    set_has_current_password();
    current_password_ = current_password;
  } else {
    clear_has_current_password();
    current_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ChangePassword.current_password)
}

// required bytes new_password = 3;
inline bool ChangePassword::has_new_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ChangePassword::set_has_new_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ChangePassword::clear_has_new_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ChangePassword::clear_new_password() {
  if (new_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_->clear();
  }
  clear_has_new_password();
}
inline const ::std::string& ChangePassword::new_password() const {
  // @@protoc_insertion_point(field_get:protocol.ChangePassword.new_password)
  return *new_password_;
}
inline void ChangePassword::set_new_password(const ::std::string& value) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.ChangePassword.new_password)
}
inline void ChangePassword::set_new_password(const char* value) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.ChangePassword.new_password)
}
inline void ChangePassword::set_new_password(const void* value, size_t size) {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_ = new ::std::string;
  }
  new_password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.ChangePassword.new_password)
}
inline ::std::string* ChangePassword::mutable_new_password() {
  set_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    new_password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.ChangePassword.new_password)
  return new_password_;
}
inline ::std::string* ChangePassword::release_new_password() {
  clear_has_new_password();
  if (new_password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = new_password_;
    new_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ChangePassword::set_allocated_new_password(::std::string* new_password) {
  if (new_password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete new_password_;
  }
  if (new_password) {
    set_has_new_password();
    new_password_ = new_password;
  } else {
    clear_has_new_password();
    new_password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ChangePassword.new_password)
}

// -------------------------------------------------------------------

// ReadValueId

// required .protocol.NodeId node_id = 1;
inline bool ReadValueId::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadValueId::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadValueId::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadValueId::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& ReadValueId::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.ReadValueId.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* ReadValueId::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.ReadValueId.node_id)
  return node_id_;
}
inline ::protocol::NodeId* ReadValueId::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void ReadValueId::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ReadValueId.node_id)
}

// required .protocol.AttributeId attribute_id = 2;
inline bool ReadValueId::has_attribute_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadValueId::set_has_attribute_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadValueId::clear_has_attribute_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadValueId::clear_attribute_id() {
  attribute_id_ = 1;
  clear_has_attribute_id();
}
inline ::protocol::AttributeId ReadValueId::attribute_id() const {
  // @@protoc_insertion_point(field_get:protocol.ReadValueId.attribute_id)
  return static_cast< ::protocol::AttributeId >(attribute_id_);
}
inline void ReadValueId::set_attribute_id(::protocol::AttributeId value) {
  assert(::protocol::AttributeId_IsValid(value));
  set_has_attribute_id();
  attribute_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.ReadValueId.attribute_id)
}

// -------------------------------------------------------------------

// Read

// repeated .protocol.ReadValueId value_id = 1;
inline int Read::value_id_size() const {
  return value_id_.size();
}
inline void Read::clear_value_id() {
  value_id_.Clear();
}
inline const ::protocol::ReadValueId& Read::value_id(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Read.value_id)
  return value_id_.Get(index);
}
inline ::protocol::ReadValueId* Read::mutable_value_id(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Read.value_id)
  return value_id_.Mutable(index);
}
inline ::protocol::ReadValueId* Read::add_value_id() {
  // @@protoc_insertion_point(field_add:protocol.Read.value_id)
  return value_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::ReadValueId >&
Read::value_id() const {
  // @@protoc_insertion_point(field_list:protocol.Read.value_id)
  return value_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::ReadValueId >*
Read::mutable_value_id() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Read.value_id)
  return &value_id_;
}

// -------------------------------------------------------------------

// ReadResponse

// repeated .protocol.DataValue result = 1;
inline int ReadResponse::result_size() const {
  return result_.size();
}
inline void ReadResponse::clear_result() {
  result_.Clear();
}
inline const ::protocol::DataValue& ReadResponse::result(int index) const {
  // @@protoc_insertion_point(field_get:protocol.ReadResponse.result)
  return result_.Get(index);
}
inline ::protocol::DataValue* ReadResponse::mutable_result(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.ReadResponse.result)
  return result_.Mutable(index);
}
inline ::protocol::DataValue* ReadResponse::add_result() {
  // @@protoc_insertion_point(field_add:protocol.ReadResponse.result)
  return result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::DataValue >&
ReadResponse::result() const {
  // @@protoc_insertion_point(field_list:protocol.ReadResponse.result)
  return result_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::DataValue >*
ReadResponse::mutable_result() {
  // @@protoc_insertion_point(field_mutable_list:protocol.ReadResponse.result)
  return &result_;
}

// -------------------------------------------------------------------

// Write

// required .protocol.NodeId node_id = 1;
inline bool Write::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Write::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Write::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Write::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& Write::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.Write.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* Write::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.Write.node_id)
  return node_id_;
}
inline ::protocol::NodeId* Write::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void Write::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Write.node_id)
}

// required double value = 2;
inline bool Write::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Write::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Write::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Write::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Write::value() const {
  // @@protoc_insertion_point(field_get:protocol.Write.value)
  return value_;
}
inline void Write::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:protocol.Write.value)
}

// optional bool select = 5;
inline bool Write::has_select() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Write::set_has_select() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Write::clear_has_select() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Write::clear_select() {
  select_ = false;
  clear_has_select();
}
inline bool Write::select() const {
  // @@protoc_insertion_point(field_get:protocol.Write.select)
  return select_;
}
inline void Write::set_select(bool value) {
  set_has_select();
  select_ = value;
  // @@protoc_insertion_point(field_set:protocol.Write.select)
}

// -------------------------------------------------------------------

// DeviceCommand

// required .protocol.NodeId node_id = 1;
inline bool DeviceCommand::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceCommand::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceCommand::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceCommand::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& DeviceCommand::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.DeviceCommand.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* DeviceCommand::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.DeviceCommand.node_id)
  return node_id_;
}
inline ::protocol::NodeId* DeviceCommand::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void DeviceCommand::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.DeviceCommand.node_id)
}

// required .protocol.NodeId method_id = 2;
inline bool DeviceCommand::has_method_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceCommand::set_has_method_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceCommand::clear_has_method_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceCommand::clear_method_id() {
  if (method_id_ != NULL) method_id_->::protocol::NodeId::Clear();
  clear_has_method_id();
}
inline const ::protocol::NodeId& DeviceCommand::method_id() const {
  // @@protoc_insertion_point(field_get:protocol.DeviceCommand.method_id)
  return method_id_ != NULL ? *method_id_ : *default_instance_->method_id_;
}
inline ::protocol::NodeId* DeviceCommand::mutable_method_id() {
  set_has_method_id();
  if (method_id_ == NULL) method_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.DeviceCommand.method_id)
  return method_id_;
}
inline ::protocol::NodeId* DeviceCommand::release_method_id() {
  clear_has_method_id();
  ::protocol::NodeId* temp = method_id_;
  method_id_ = NULL;
  return temp;
}
inline void DeviceCommand::set_allocated_method_id(::protocol::NodeId* method_id) {
  delete method_id_;
  method_id_ = method_id;
  if (method_id) {
    set_has_method_id();
  } else {
    clear_has_method_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.DeviceCommand.method_id)
}

// repeated .protocol.Variant argument = 3;
inline int DeviceCommand::argument_size() const {
  return argument_.size();
}
inline void DeviceCommand::clear_argument() {
  argument_.Clear();
}
inline const ::protocol::Variant& DeviceCommand::argument(int index) const {
  // @@protoc_insertion_point(field_get:protocol.DeviceCommand.argument)
  return argument_.Get(index);
}
inline ::protocol::Variant* DeviceCommand::mutable_argument(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.DeviceCommand.argument)
  return argument_.Mutable(index);
}
inline ::protocol::Variant* DeviceCommand::add_argument() {
  // @@protoc_insertion_point(field_add:protocol.DeviceCommand.argument)
  return argument_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Variant >&
DeviceCommand::argument() const {
  // @@protoc_insertion_point(field_list:protocol.DeviceCommand.argument)
  return argument_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Variant >*
DeviceCommand::mutable_argument() {
  // @@protoc_insertion_point(field_mutable_list:protocol.DeviceCommand.argument)
  return &argument_;
}

// -------------------------------------------------------------------

// Acknowledge

// required uint64 event_id = 1;
inline bool Acknowledge::has_event_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Acknowledge::set_has_event_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Acknowledge::clear_has_event_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Acknowledge::clear_event_id() {
  event_id_ = GOOGLE_ULONGLONG(0);
  clear_has_event_id();
}
inline ::google::protobuf::uint64 Acknowledge::event_id() const {
  // @@protoc_insertion_point(field_get:protocol.Acknowledge.event_id)
  return event_id_;
}
inline void Acknowledge::set_event_id(::google::protobuf::uint64 value) {
  set_has_event_id();
  event_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Acknowledge.event_id)
}

// optional bytes comment = 2;
inline bool Acknowledge::has_comment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Acknowledge::set_has_comment() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Acknowledge::clear_has_comment() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Acknowledge::clear_comment() {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Acknowledge::comment() const {
  // @@protoc_insertion_point(field_get:protocol.Acknowledge.comment)
  return *comment_;
}
inline void Acknowledge::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set:protocol.Acknowledge.comment)
}
inline void Acknowledge::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
  // @@protoc_insertion_point(field_set_char:protocol.Acknowledge.comment)
}
inline void Acknowledge::set_comment(const void* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:protocol.Acknowledge.comment)
}
inline ::std::string* Acknowledge::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    comment_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:protocol.Acknowledge.comment)
  return comment_;
}
inline ::std::string* Acknowledge::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Acknowledge::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Acknowledge.comment)
}

// -------------------------------------------------------------------

// Call

// optional .protocol.DeviceCommand device_command = 1;
inline bool Call::has_device_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Call::set_has_device_command() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Call::clear_has_device_command() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Call::clear_device_command() {
  if (device_command_ != NULL) device_command_->::protocol::DeviceCommand::Clear();
  clear_has_device_command();
}
inline const ::protocol::DeviceCommand& Call::device_command() const {
  // @@protoc_insertion_point(field_get:protocol.Call.device_command)
  return device_command_ != NULL ? *device_command_ : *default_instance_->device_command_;
}
inline ::protocol::DeviceCommand* Call::mutable_device_command() {
  set_has_device_command();
  if (device_command_ == NULL) device_command_ = new ::protocol::DeviceCommand;
  // @@protoc_insertion_point(field_mutable:protocol.Call.device_command)
  return device_command_;
}
inline ::protocol::DeviceCommand* Call::release_device_command() {
  clear_has_device_command();
  ::protocol::DeviceCommand* temp = device_command_;
  device_command_ = NULL;
  return temp;
}
inline void Call::set_allocated_device_command(::protocol::DeviceCommand* device_command) {
  delete device_command_;
  device_command_ = device_command;
  if (device_command) {
    set_has_device_command();
  } else {
    clear_has_device_command();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Call.device_command)
}

// optional .protocol.Acknowledge acknowledge = 2;
inline bool Call::has_acknowledge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Call::set_has_acknowledge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Call::clear_has_acknowledge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Call::clear_acknowledge() {
  if (acknowledge_ != NULL) acknowledge_->::protocol::Acknowledge::Clear();
  clear_has_acknowledge();
}
inline const ::protocol::Acknowledge& Call::acknowledge() const {
  // @@protoc_insertion_point(field_get:protocol.Call.acknowledge)
  return acknowledge_ != NULL ? *acknowledge_ : *default_instance_->acknowledge_;
}
inline ::protocol::Acknowledge* Call::mutable_acknowledge() {
  set_has_acknowledge();
  if (acknowledge_ == NULL) acknowledge_ = new ::protocol::Acknowledge;
  // @@protoc_insertion_point(field_mutable:protocol.Call.acknowledge)
  return acknowledge_;
}
inline ::protocol::Acknowledge* Call::release_acknowledge() {
  clear_has_acknowledge();
  ::protocol::Acknowledge* temp = acknowledge_;
  acknowledge_ = NULL;
  return temp;
}
inline void Call::set_allocated_acknowledge(::protocol::Acknowledge* acknowledge) {
  delete acknowledge_;
  acknowledge_ = acknowledge;
  if (acknowledge) {
    set_has_acknowledge();
  } else {
    clear_has_acknowledge();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Call.acknowledge)
}

// -------------------------------------------------------------------

// EventFilter

// optional bool acked = 1;
inline bool EventFilter::has_acked() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EventFilter::set_has_acked() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EventFilter::clear_has_acked() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EventFilter::clear_acked() {
  acked_ = false;
  clear_has_acked();
}
inline bool EventFilter::acked() const {
  // @@protoc_insertion_point(field_get:protocol.EventFilter.acked)
  return acked_;
}
inline void EventFilter::set_acked(bool value) {
  set_has_acked();
  acked_ = value;
  // @@protoc_insertion_point(field_set:protocol.EventFilter.acked)
}

// optional bool unacked = 2;
inline bool EventFilter::has_unacked() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EventFilter::set_has_unacked() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EventFilter::clear_has_unacked() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EventFilter::clear_unacked() {
  unacked_ = false;
  clear_has_unacked();
}
inline bool EventFilter::unacked() const {
  // @@protoc_insertion_point(field_get:protocol.EventFilter.unacked)
  return unacked_;
}
inline void EventFilter::set_unacked(bool value) {
  set_has_unacked();
  unacked_ = value;
  // @@protoc_insertion_point(field_set:protocol.EventFilter.unacked)
}

// -------------------------------------------------------------------

// HistoryRead

// required .protocol.NodeId node_id = 1;
inline bool HistoryRead::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryRead::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryRead::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryRead::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& HistoryRead::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.HistoryRead.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* HistoryRead::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.HistoryRead.node_id)
  return node_id_;
}
inline ::protocol::NodeId* HistoryRead::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void HistoryRead::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.HistoryRead.node_id)
}

// required .protocol.AttributeId attribute_id = 2;
inline bool HistoryRead::has_attribute_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HistoryRead::set_has_attribute_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HistoryRead::clear_has_attribute_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HistoryRead::clear_attribute_id() {
  attribute_id_ = 1;
  clear_has_attribute_id();
}
inline ::protocol::AttributeId HistoryRead::attribute_id() const {
  // @@protoc_insertion_point(field_get:protocol.HistoryRead.attribute_id)
  return static_cast< ::protocol::AttributeId >(attribute_id_);
}
inline void HistoryRead::set_attribute_id(::protocol::AttributeId value) {
  assert(::protocol::AttributeId_IsValid(value));
  set_has_attribute_id();
  attribute_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.HistoryRead.attribute_id)
}

// required uint64 from = 3;
inline bool HistoryRead::has_from() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HistoryRead::set_has_from() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HistoryRead::clear_has_from() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HistoryRead::clear_from() {
  from_ = GOOGLE_ULONGLONG(0);
  clear_has_from();
}
inline ::google::protobuf::uint64 HistoryRead::from() const {
  // @@protoc_insertion_point(field_get:protocol.HistoryRead.from)
  return from_;
}
inline void HistoryRead::set_from(::google::protobuf::uint64 value) {
  set_has_from();
  from_ = value;
  // @@protoc_insertion_point(field_set:protocol.HistoryRead.from)
}

// optional uint64 to = 4;
inline bool HistoryRead::has_to() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HistoryRead::set_has_to() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HistoryRead::clear_has_to() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HistoryRead::clear_to() {
  to_ = GOOGLE_ULONGLONG(0);
  clear_has_to();
}
inline ::google::protobuf::uint64 HistoryRead::to() const {
  // @@protoc_insertion_point(field_get:protocol.HistoryRead.to)
  return to_;
}
inline void HistoryRead::set_to(::google::protobuf::uint64 value) {
  set_has_to();
  to_ = value;
  // @@protoc_insertion_point(field_set:protocol.HistoryRead.to)
}

// optional .protocol.EventFilter event_filter = 5;
inline bool HistoryRead::has_event_filter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HistoryRead::set_has_event_filter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HistoryRead::clear_has_event_filter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HistoryRead::clear_event_filter() {
  if (event_filter_ != NULL) event_filter_->::protocol::EventFilter::Clear();
  clear_has_event_filter();
}
inline const ::protocol::EventFilter& HistoryRead::event_filter() const {
  // @@protoc_insertion_point(field_get:protocol.HistoryRead.event_filter)
  return event_filter_ != NULL ? *event_filter_ : *default_instance_->event_filter_;
}
inline ::protocol::EventFilter* HistoryRead::mutable_event_filter() {
  set_has_event_filter();
  if (event_filter_ == NULL) event_filter_ = new ::protocol::EventFilter;
  // @@protoc_insertion_point(field_mutable:protocol.HistoryRead.event_filter)
  return event_filter_;
}
inline ::protocol::EventFilter* HistoryRead::release_event_filter() {
  clear_has_event_filter();
  ::protocol::EventFilter* temp = event_filter_;
  event_filter_ = NULL;
  return temp;
}
inline void HistoryRead::set_allocated_event_filter(::protocol::EventFilter* event_filter) {
  delete event_filter_;
  event_filter_ = event_filter;
  if (event_filter) {
    set_has_event_filter();
  } else {
    clear_has_event_filter();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.HistoryRead.event_filter)
}

// -------------------------------------------------------------------

// HistoryReadResult

// repeated .protocol.DataValue values = 1;
inline int HistoryReadResult::values_size() const {
  return values_.size();
}
inline void HistoryReadResult::clear_values() {
  values_.Clear();
}
inline const ::protocol::DataValue& HistoryReadResult::values(int index) const {
  // @@protoc_insertion_point(field_get:protocol.HistoryReadResult.values)
  return values_.Get(index);
}
inline ::protocol::DataValue* HistoryReadResult::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.HistoryReadResult.values)
  return values_.Mutable(index);
}
inline ::protocol::DataValue* HistoryReadResult::add_values() {
  // @@protoc_insertion_point(field_add:protocol.HistoryReadResult.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::DataValue >&
HistoryReadResult::values() const {
  // @@protoc_insertion_point(field_list:protocol.HistoryReadResult.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::DataValue >*
HistoryReadResult::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:protocol.HistoryReadResult.values)
  return &values_;
}

// repeated .protocol.Event events = 2;
inline int HistoryReadResult::events_size() const {
  return events_.size();
}
inline void HistoryReadResult::clear_events() {
  events_.Clear();
}
inline const ::protocol::Event& HistoryReadResult::events(int index) const {
  // @@protoc_insertion_point(field_get:protocol.HistoryReadResult.events)
  return events_.Get(index);
}
inline ::protocol::Event* HistoryReadResult::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.HistoryReadResult.events)
  return events_.Mutable(index);
}
inline ::protocol::Event* HistoryReadResult::add_events() {
  // @@protoc_insertion_point(field_add:protocol.HistoryReadResult.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Event >&
HistoryReadResult::events() const {
  // @@protoc_insertion_point(field_list:protocol.HistoryReadResult.events)
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Event >*
HistoryReadResult::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:protocol.HistoryReadResult.events)
  return &events_;
}

// -------------------------------------------------------------------

// CreateSubscription

// optional uint32 update_rate_ms = 1;
inline bool CreateSubscription::has_update_rate_ms() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSubscription::set_has_update_rate_ms() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSubscription::clear_has_update_rate_ms() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSubscription::clear_update_rate_ms() {
  update_rate_ms_ = 0u;
  clear_has_update_rate_ms();
}
inline ::google::protobuf::uint32 CreateSubscription::update_rate_ms() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSubscription.update_rate_ms)
  return update_rate_ms_;
}
inline void CreateSubscription::set_update_rate_ms(::google::protobuf::uint32 value) {
  set_has_update_rate_ms();
  update_rate_ms_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateSubscription.update_rate_ms)
}

// optional .protocol.EventFilter event_filter = 2;
inline bool CreateSubscription::has_event_filter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateSubscription::set_has_event_filter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateSubscription::clear_has_event_filter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateSubscription::clear_event_filter() {
  if (event_filter_ != NULL) event_filter_->::protocol::EventFilter::Clear();
  clear_has_event_filter();
}
inline const ::protocol::EventFilter& CreateSubscription::event_filter() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSubscription.event_filter)
  return event_filter_ != NULL ? *event_filter_ : *default_instance_->event_filter_;
}
inline ::protocol::EventFilter* CreateSubscription::mutable_event_filter() {
  set_has_event_filter();
  if (event_filter_ == NULL) event_filter_ = new ::protocol::EventFilter;
  // @@protoc_insertion_point(field_mutable:protocol.CreateSubscription.event_filter)
  return event_filter_;
}
inline ::protocol::EventFilter* CreateSubscription::release_event_filter() {
  clear_has_event_filter();
  ::protocol::EventFilter* temp = event_filter_;
  event_filter_ = NULL;
  return temp;
}
inline void CreateSubscription::set_allocated_event_filter(::protocol::EventFilter* event_filter) {
  delete event_filter_;
  event_filter_ = event_filter;
  if (event_filter) {
    set_has_event_filter();
  } else {
    clear_has_event_filter();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateSubscription.event_filter)
}

// -------------------------------------------------------------------

// CreateSubscriptionResult

// optional uint32 subscription_id = 1;
inline bool CreateSubscriptionResult::has_subscription_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateSubscriptionResult::set_has_subscription_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateSubscriptionResult::clear_has_subscription_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateSubscriptionResult::clear_subscription_id() {
  subscription_id_ = 0u;
  clear_has_subscription_id();
}
inline ::google::protobuf::uint32 CreateSubscriptionResult::subscription_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateSubscriptionResult.subscription_id)
  return subscription_id_;
}
inline void CreateSubscriptionResult::set_subscription_id(::google::protobuf::uint32 value) {
  set_has_subscription_id();
  subscription_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateSubscriptionResult.subscription_id)
}

// -------------------------------------------------------------------

// DeleteSubscription

// required uint32 subscription_id = 1;
inline bool DeleteSubscription::has_subscription_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteSubscription::set_has_subscription_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteSubscription::clear_has_subscription_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteSubscription::clear_subscription_id() {
  subscription_id_ = 0u;
  clear_has_subscription_id();
}
inline ::google::protobuf::uint32 DeleteSubscription::subscription_id() const {
  // @@protoc_insertion_point(field_get:protocol.DeleteSubscription.subscription_id)
  return subscription_id_;
}
inline void DeleteSubscription::set_subscription_id(::google::protobuf::uint32 value) {
  set_has_subscription_id();
  subscription_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.DeleteSubscription.subscription_id)
}

// -------------------------------------------------------------------

// CreateMonitoredItem

// required uint32 subscription_id = 1;
inline bool CreateMonitoredItem::has_subscription_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateMonitoredItem::set_has_subscription_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateMonitoredItem::clear_has_subscription_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateMonitoredItem::clear_subscription_id() {
  subscription_id_ = 0u;
  clear_has_subscription_id();
}
inline ::google::protobuf::uint32 CreateMonitoredItem::subscription_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateMonitoredItem.subscription_id)
  return subscription_id_;
}
inline void CreateMonitoredItem::set_subscription_id(::google::protobuf::uint32 value) {
  set_has_subscription_id();
  subscription_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateMonitoredItem.subscription_id)
}

// required .protocol.NodeId node_id = 2;
inline bool CreateMonitoredItem::has_node_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateMonitoredItem::set_has_node_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateMonitoredItem::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateMonitoredItem::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& CreateMonitoredItem::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateMonitoredItem.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* CreateMonitoredItem::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.CreateMonitoredItem.node_id)
  return node_id_;
}
inline ::protocol::NodeId* CreateMonitoredItem::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void CreateMonitoredItem::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.CreateMonitoredItem.node_id)
}

// required .protocol.AttributeId attribute_id = 3;
inline bool CreateMonitoredItem::has_attribute_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateMonitoredItem::set_has_attribute_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateMonitoredItem::clear_has_attribute_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateMonitoredItem::clear_attribute_id() {
  attribute_id_ = 1;
  clear_has_attribute_id();
}
inline ::protocol::AttributeId CreateMonitoredItem::attribute_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateMonitoredItem.attribute_id)
  return static_cast< ::protocol::AttributeId >(attribute_id_);
}
inline void CreateMonitoredItem::set_attribute_id(::protocol::AttributeId value) {
  assert(::protocol::AttributeId_IsValid(value));
  set_has_attribute_id();
  attribute_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateMonitoredItem.attribute_id)
}

// -------------------------------------------------------------------

// CreateMonitoredItemResult

// optional uint32 monitored_item_id = 21;
inline bool CreateMonitoredItemResult::has_monitored_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateMonitoredItemResult::set_has_monitored_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateMonitoredItemResult::clear_has_monitored_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateMonitoredItemResult::clear_monitored_item_id() {
  monitored_item_id_ = 0u;
  clear_has_monitored_item_id();
}
inline ::google::protobuf::uint32 CreateMonitoredItemResult::monitored_item_id() const {
  // @@protoc_insertion_point(field_get:protocol.CreateMonitoredItemResult.monitored_item_id)
  return monitored_item_id_;
}
inline void CreateMonitoredItemResult::set_monitored_item_id(::google::protobuf::uint32 value) {
  set_has_monitored_item_id();
  monitored_item_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.CreateMonitoredItemResult.monitored_item_id)
}

// -------------------------------------------------------------------

// DeleteMonitoredItem

// required uint32 subscription_id = 1;
inline bool DeleteMonitoredItem::has_subscription_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteMonitoredItem::set_has_subscription_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteMonitoredItem::clear_has_subscription_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteMonitoredItem::clear_subscription_id() {
  subscription_id_ = 0u;
  clear_has_subscription_id();
}
inline ::google::protobuf::uint32 DeleteMonitoredItem::subscription_id() const {
  // @@protoc_insertion_point(field_get:protocol.DeleteMonitoredItem.subscription_id)
  return subscription_id_;
}
inline void DeleteMonitoredItem::set_subscription_id(::google::protobuf::uint32 value) {
  set_has_subscription_id();
  subscription_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.DeleteMonitoredItem.subscription_id)
}

// required uint32 monitored_item_id = 2;
inline bool DeleteMonitoredItem::has_monitored_item_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteMonitoredItem::set_has_monitored_item_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteMonitoredItem::clear_has_monitored_item_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteMonitoredItem::clear_monitored_item_id() {
  monitored_item_id_ = 0u;
  clear_has_monitored_item_id();
}
inline ::google::protobuf::uint32 DeleteMonitoredItem::monitored_item_id() const {
  // @@protoc_insertion_point(field_get:protocol.DeleteMonitoredItem.monitored_item_id)
  return monitored_item_id_;
}
inline void DeleteMonitoredItem::set_monitored_item_id(::google::protobuf::uint32 value) {
  set_has_monitored_item_id();
  monitored_item_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.DeleteMonitoredItem.monitored_item_id)
}

// -------------------------------------------------------------------

// BrowseDescription

// required .protocol.NodeId node_id = 1;
inline bool BrowseDescription::has_node_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrowseDescription::set_has_node_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrowseDescription::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrowseDescription::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& BrowseDescription::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.BrowseDescription.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* BrowseDescription::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.BrowseDescription.node_id)
  return node_id_;
}
inline ::protocol::NodeId* BrowseDescription::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void BrowseDescription::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.BrowseDescription.node_id)
}

// optional .protocol.BrowseDirection direction = 2;
inline bool BrowseDescription::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BrowseDescription::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BrowseDescription::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BrowseDescription::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::protocol::BrowseDirection BrowseDescription::direction() const {
  // @@protoc_insertion_point(field_get:protocol.BrowseDescription.direction)
  return static_cast< ::protocol::BrowseDirection >(direction_);
}
inline void BrowseDescription::set_direction(::protocol::BrowseDirection value) {
  assert(::protocol::BrowseDirection_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:protocol.BrowseDescription.direction)
}

// optional .protocol.NodeId reference_type_id = 3;
inline bool BrowseDescription::has_reference_type_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BrowseDescription::set_has_reference_type_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BrowseDescription::clear_has_reference_type_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BrowseDescription::clear_reference_type_id() {
  if (reference_type_id_ != NULL) reference_type_id_->::protocol::NodeId::Clear();
  clear_has_reference_type_id();
}
inline const ::protocol::NodeId& BrowseDescription::reference_type_id() const {
  // @@protoc_insertion_point(field_get:protocol.BrowseDescription.reference_type_id)
  return reference_type_id_ != NULL ? *reference_type_id_ : *default_instance_->reference_type_id_;
}
inline ::protocol::NodeId* BrowseDescription::mutable_reference_type_id() {
  set_has_reference_type_id();
  if (reference_type_id_ == NULL) reference_type_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.BrowseDescription.reference_type_id)
  return reference_type_id_;
}
inline ::protocol::NodeId* BrowseDescription::release_reference_type_id() {
  clear_has_reference_type_id();
  ::protocol::NodeId* temp = reference_type_id_;
  reference_type_id_ = NULL;
  return temp;
}
inline void BrowseDescription::set_allocated_reference_type_id(::protocol::NodeId* reference_type_id) {
  delete reference_type_id_;
  reference_type_id_ = reference_type_id;
  if (reference_type_id) {
    set_has_reference_type_id();
  } else {
    clear_has_reference_type_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.BrowseDescription.reference_type_id)
}

// optional bool include_subtypes = 4;
inline bool BrowseDescription::has_include_subtypes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BrowseDescription::set_has_include_subtypes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BrowseDescription::clear_has_include_subtypes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BrowseDescription::clear_include_subtypes() {
  include_subtypes_ = false;
  clear_has_include_subtypes();
}
inline bool BrowseDescription::include_subtypes() const {
  // @@protoc_insertion_point(field_get:protocol.BrowseDescription.include_subtypes)
  return include_subtypes_;
}
inline void BrowseDescription::set_include_subtypes(bool value) {
  set_has_include_subtypes();
  include_subtypes_ = value;
  // @@protoc_insertion_point(field_set:protocol.BrowseDescription.include_subtypes)
}

// -------------------------------------------------------------------

// Browse

// repeated .protocol.BrowseDescription nodes = 1;
inline int Browse::nodes_size() const {
  return nodes_.size();
}
inline void Browse::clear_nodes() {
  nodes_.Clear();
}
inline const ::protocol::BrowseDescription& Browse::nodes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Browse.nodes)
  return nodes_.Get(index);
}
inline ::protocol::BrowseDescription* Browse::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Browse.nodes)
  return nodes_.Mutable(index);
}
inline ::protocol::BrowseDescription* Browse::add_nodes() {
  // @@protoc_insertion_point(field_add:protocol.Browse.nodes)
  return nodes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::BrowseDescription >&
Browse::nodes() const {
  // @@protoc_insertion_point(field_list:protocol.Browse.nodes)
  return nodes_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::BrowseDescription >*
Browse::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Browse.nodes)
  return &nodes_;
}

// -------------------------------------------------------------------

// ReferenceDescription

// required .protocol.NodeId reference_type_id = 1;
inline bool ReferenceDescription::has_reference_type_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReferenceDescription::set_has_reference_type_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReferenceDescription::clear_has_reference_type_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReferenceDescription::clear_reference_type_id() {
  if (reference_type_id_ != NULL) reference_type_id_->::protocol::NodeId::Clear();
  clear_has_reference_type_id();
}
inline const ::protocol::NodeId& ReferenceDescription::reference_type_id() const {
  // @@protoc_insertion_point(field_get:protocol.ReferenceDescription.reference_type_id)
  return reference_type_id_ != NULL ? *reference_type_id_ : *default_instance_->reference_type_id_;
}
inline ::protocol::NodeId* ReferenceDescription::mutable_reference_type_id() {
  set_has_reference_type_id();
  if (reference_type_id_ == NULL) reference_type_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.ReferenceDescription.reference_type_id)
  return reference_type_id_;
}
inline ::protocol::NodeId* ReferenceDescription::release_reference_type_id() {
  clear_has_reference_type_id();
  ::protocol::NodeId* temp = reference_type_id_;
  reference_type_id_ = NULL;
  return temp;
}
inline void ReferenceDescription::set_allocated_reference_type_id(::protocol::NodeId* reference_type_id) {
  delete reference_type_id_;
  reference_type_id_ = reference_type_id;
  if (reference_type_id) {
    set_has_reference_type_id();
  } else {
    clear_has_reference_type_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ReferenceDescription.reference_type_id)
}

// required bool forward = 2;
inline bool ReferenceDescription::has_forward() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReferenceDescription::set_has_forward() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReferenceDescription::clear_has_forward() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReferenceDescription::clear_forward() {
  forward_ = false;
  clear_has_forward();
}
inline bool ReferenceDescription::forward() const {
  // @@protoc_insertion_point(field_get:protocol.ReferenceDescription.forward)
  return forward_;
}
inline void ReferenceDescription::set_forward(bool value) {
  set_has_forward();
  forward_ = value;
  // @@protoc_insertion_point(field_set:protocol.ReferenceDescription.forward)
}

// required .protocol.NodeId node_id = 3;
inline bool ReferenceDescription::has_node_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReferenceDescription::set_has_node_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReferenceDescription::clear_has_node_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReferenceDescription::clear_node_id() {
  if (node_id_ != NULL) node_id_->::protocol::NodeId::Clear();
  clear_has_node_id();
}
inline const ::protocol::NodeId& ReferenceDescription::node_id() const {
  // @@protoc_insertion_point(field_get:protocol.ReferenceDescription.node_id)
  return node_id_ != NULL ? *node_id_ : *default_instance_->node_id_;
}
inline ::protocol::NodeId* ReferenceDescription::mutable_node_id() {
  set_has_node_id();
  if (node_id_ == NULL) node_id_ = new ::protocol::NodeId;
  // @@protoc_insertion_point(field_mutable:protocol.ReferenceDescription.node_id)
  return node_id_;
}
inline ::protocol::NodeId* ReferenceDescription::release_node_id() {
  clear_has_node_id();
  ::protocol::NodeId* temp = node_id_;
  node_id_ = NULL;
  return temp;
}
inline void ReferenceDescription::set_allocated_node_id(::protocol::NodeId* node_id) {
  delete node_id_;
  node_id_ = node_id;
  if (node_id) {
    set_has_node_id();
  } else {
    clear_has_node_id();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.ReferenceDescription.node_id)
}

// -------------------------------------------------------------------

// BrowseResult

// optional uint32 status_code = 1;
inline bool BrowseResult::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrowseResult::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrowseResult::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrowseResult::clear_status_code() {
  status_code_ = 0u;
  clear_has_status_code();
}
inline ::google::protobuf::uint32 BrowseResult::status_code() const {
  // @@protoc_insertion_point(field_get:protocol.BrowseResult.status_code)
  return status_code_;
}
inline void BrowseResult::set_status_code(::google::protobuf::uint32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:protocol.BrowseResult.status_code)
}

// repeated .protocol.ReferenceDescription references = 2;
inline int BrowseResult::references_size() const {
  return references_.size();
}
inline void BrowseResult::clear_references() {
  references_.Clear();
}
inline const ::protocol::ReferenceDescription& BrowseResult::references(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BrowseResult.references)
  return references_.Get(index);
}
inline ::protocol::ReferenceDescription* BrowseResult::mutable_references(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BrowseResult.references)
  return references_.Mutable(index);
}
inline ::protocol::ReferenceDescription* BrowseResult::add_references() {
  // @@protoc_insertion_point(field_add:protocol.BrowseResult.references)
  return references_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::ReferenceDescription >&
BrowseResult::references() const {
  // @@protoc_insertion_point(field_list:protocol.BrowseResult.references)
  return references_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::ReferenceDescription >*
BrowseResult::mutable_references() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BrowseResult.references)
  return &references_;
}

// -------------------------------------------------------------------

// BrowseResponse

// required .protocol.Status status = 1;
inline bool BrowseResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BrowseResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BrowseResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BrowseResponse::clear_status() {
  if (status_ != NULL) status_->::protocol::Status::Clear();
  clear_has_status();
}
inline const ::protocol::Status& BrowseResponse::status() const {
  // @@protoc_insertion_point(field_get:protocol.BrowseResponse.status)
  return status_ != NULL ? *status_ : *default_instance_->status_;
}
inline ::protocol::Status* BrowseResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) status_ = new ::protocol::Status;
  // @@protoc_insertion_point(field_mutable:protocol.BrowseResponse.status)
  return status_;
}
inline ::protocol::Status* BrowseResponse::release_status() {
  clear_has_status();
  ::protocol::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline void BrowseResponse::set_allocated_status(::protocol::Status* status) {
  delete status_;
  status_ = status;
  if (status) {
    set_has_status();
  } else {
    clear_has_status();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.BrowseResponse.status)
}

// repeated .protocol.BrowseResult results = 2;
inline int BrowseResponse::results_size() const {
  return results_.size();
}
inline void BrowseResponse::clear_results() {
  results_.Clear();
}
inline const ::protocol::BrowseResult& BrowseResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:protocol.BrowseResponse.results)
  return results_.Get(index);
}
inline ::protocol::BrowseResult* BrowseResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.BrowseResponse.results)
  return results_.Mutable(index);
}
inline ::protocol::BrowseResult* BrowseResponse::add_results() {
  // @@protoc_insertion_point(field_add:protocol.BrowseResponse.results)
  return results_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::BrowseResult >&
BrowseResponse::results() const {
  // @@protoc_insertion_point(field_list:protocol.BrowseResponse.results)
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::BrowseResult >*
BrowseResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:protocol.BrowseResponse.results)
  return &results_;
}

// -------------------------------------------------------------------

// Request

// optional uint32 request_id = 1;
inline bool Request::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Request::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Request::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Request::clear_request_id() {
  request_id_ = 0u;
  clear_has_request_id();
}
inline ::google::protobuf::uint32 Request::request_id() const {
  // @@protoc_insertion_point(field_get:protocol.Request.request_id)
  return request_id_;
}
inline void Request::set_request_id(::google::protobuf::uint32 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Request.request_id)
}

// optional .protocol.CreateSession create_session = 10;
inline bool Request::has_create_session() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Request::set_has_create_session() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Request::clear_has_create_session() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Request::clear_create_session() {
  if (create_session_ != NULL) create_session_->::protocol::CreateSession::Clear();
  clear_has_create_session();
}
inline const ::protocol::CreateSession& Request::create_session() const {
  // @@protoc_insertion_point(field_get:protocol.Request.create_session)
  return create_session_ != NULL ? *create_session_ : *default_instance_->create_session_;
}
inline ::protocol::CreateSession* Request::mutable_create_session() {
  set_has_create_session();
  if (create_session_ == NULL) create_session_ = new ::protocol::CreateSession;
  // @@protoc_insertion_point(field_mutable:protocol.Request.create_session)
  return create_session_;
}
inline ::protocol::CreateSession* Request::release_create_session() {
  clear_has_create_session();
  ::protocol::CreateSession* temp = create_session_;
  create_session_ = NULL;
  return temp;
}
inline void Request::set_allocated_create_session(::protocol::CreateSession* create_session) {
  delete create_session_;
  create_session_ = create_session;
  if (create_session) {
    set_has_create_session();
  } else {
    clear_has_create_session();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.create_session)
}

// optional .protocol.DeleteSession delete_session = 11;
inline bool Request::has_delete_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Request::set_has_delete_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Request::clear_has_delete_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Request::clear_delete_session() {
  if (delete_session_ != NULL) delete_session_->::protocol::DeleteSession::Clear();
  clear_has_delete_session();
}
inline const ::protocol::DeleteSession& Request::delete_session() const {
  // @@protoc_insertion_point(field_get:protocol.Request.delete_session)
  return delete_session_ != NULL ? *delete_session_ : *default_instance_->delete_session_;
}
inline ::protocol::DeleteSession* Request::mutable_delete_session() {
  set_has_delete_session();
  if (delete_session_ == NULL) delete_session_ = new ::protocol::DeleteSession;
  // @@protoc_insertion_point(field_mutable:protocol.Request.delete_session)
  return delete_session_;
}
inline ::protocol::DeleteSession* Request::release_delete_session() {
  clear_has_delete_session();
  ::protocol::DeleteSession* temp = delete_session_;
  delete_session_ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_session(::protocol::DeleteSession* delete_session) {
  delete delete_session_;
  delete_session_ = delete_session;
  if (delete_session) {
    set_has_delete_session();
  } else {
    clear_has_delete_session();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.delete_session)
}

// optional .protocol.Read read = 14;
inline bool Request::has_read() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Request::set_has_read() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Request::clear_has_read() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Request::clear_read() {
  if (read_ != NULL) read_->::protocol::Read::Clear();
  clear_has_read();
}
inline const ::protocol::Read& Request::read() const {
  // @@protoc_insertion_point(field_get:protocol.Request.read)
  return read_ != NULL ? *read_ : *default_instance_->read_;
}
inline ::protocol::Read* Request::mutable_read() {
  set_has_read();
  if (read_ == NULL) read_ = new ::protocol::Read;
  // @@protoc_insertion_point(field_mutable:protocol.Request.read)
  return read_;
}
inline ::protocol::Read* Request::release_read() {
  clear_has_read();
  ::protocol::Read* temp = read_;
  read_ = NULL;
  return temp;
}
inline void Request::set_allocated_read(::protocol::Read* read) {
  delete read_;
  read_ = read;
  if (read) {
    set_has_read();
  } else {
    clear_has_read();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.read)
}

// optional .protocol.Write write = 12;
inline bool Request::has_write() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Request::set_has_write() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Request::clear_has_write() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Request::clear_write() {
  if (write_ != NULL) write_->::protocol::Write::Clear();
  clear_has_write();
}
inline const ::protocol::Write& Request::write() const {
  // @@protoc_insertion_point(field_get:protocol.Request.write)
  return write_ != NULL ? *write_ : *default_instance_->write_;
}
inline ::protocol::Write* Request::mutable_write() {
  set_has_write();
  if (write_ == NULL) write_ = new ::protocol::Write;
  // @@protoc_insertion_point(field_mutable:protocol.Request.write)
  return write_;
}
inline ::protocol::Write* Request::release_write() {
  clear_has_write();
  ::protocol::Write* temp = write_;
  write_ = NULL;
  return temp;
}
inline void Request::set_allocated_write(::protocol::Write* write) {
  delete write_;
  write_ = write;
  if (write) {
    set_has_write();
  } else {
    clear_has_write();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.write)
}

// optional .protocol.Call call = 13;
inline bool Request::has_call() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Request::set_has_call() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Request::clear_has_call() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Request::clear_call() {
  if (call_ != NULL) call_->::protocol::Call::Clear();
  clear_has_call();
}
inline const ::protocol::Call& Request::call() const {
  // @@protoc_insertion_point(field_get:protocol.Request.call)
  return call_ != NULL ? *call_ : *default_instance_->call_;
}
inline ::protocol::Call* Request::mutable_call() {
  set_has_call();
  if (call_ == NULL) call_ = new ::protocol::Call;
  // @@protoc_insertion_point(field_mutable:protocol.Request.call)
  return call_;
}
inline ::protocol::Call* Request::release_call() {
  clear_has_call();
  ::protocol::Call* temp = call_;
  call_ = NULL;
  return temp;
}
inline void Request::set_allocated_call(::protocol::Call* call) {
  delete call_;
  call_ = call;
  if (call) {
    set_has_call();
  } else {
    clear_has_call();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.call)
}

// optional .protocol.CreateSubscription create_subscription = 20;
inline bool Request::has_create_subscription() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Request::set_has_create_subscription() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Request::clear_has_create_subscription() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Request::clear_create_subscription() {
  if (create_subscription_ != NULL) create_subscription_->::protocol::CreateSubscription::Clear();
  clear_has_create_subscription();
}
inline const ::protocol::CreateSubscription& Request::create_subscription() const {
  // @@protoc_insertion_point(field_get:protocol.Request.create_subscription)
  return create_subscription_ != NULL ? *create_subscription_ : *default_instance_->create_subscription_;
}
inline ::protocol::CreateSubscription* Request::mutable_create_subscription() {
  set_has_create_subscription();
  if (create_subscription_ == NULL) create_subscription_ = new ::protocol::CreateSubscription;
  // @@protoc_insertion_point(field_mutable:protocol.Request.create_subscription)
  return create_subscription_;
}
inline ::protocol::CreateSubscription* Request::release_create_subscription() {
  clear_has_create_subscription();
  ::protocol::CreateSubscription* temp = create_subscription_;
  create_subscription_ = NULL;
  return temp;
}
inline void Request::set_allocated_create_subscription(::protocol::CreateSubscription* create_subscription) {
  delete create_subscription_;
  create_subscription_ = create_subscription;
  if (create_subscription) {
    set_has_create_subscription();
  } else {
    clear_has_create_subscription();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.create_subscription)
}

// optional .protocol.DeleteSubscription delete_subscription = 21;
inline bool Request::has_delete_subscription() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Request::set_has_delete_subscription() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Request::clear_has_delete_subscription() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Request::clear_delete_subscription() {
  if (delete_subscription_ != NULL) delete_subscription_->::protocol::DeleteSubscription::Clear();
  clear_has_delete_subscription();
}
inline const ::protocol::DeleteSubscription& Request::delete_subscription() const {
  // @@protoc_insertion_point(field_get:protocol.Request.delete_subscription)
  return delete_subscription_ != NULL ? *delete_subscription_ : *default_instance_->delete_subscription_;
}
inline ::protocol::DeleteSubscription* Request::mutable_delete_subscription() {
  set_has_delete_subscription();
  if (delete_subscription_ == NULL) delete_subscription_ = new ::protocol::DeleteSubscription;
  // @@protoc_insertion_point(field_mutable:protocol.Request.delete_subscription)
  return delete_subscription_;
}
inline ::protocol::DeleteSubscription* Request::release_delete_subscription() {
  clear_has_delete_subscription();
  ::protocol::DeleteSubscription* temp = delete_subscription_;
  delete_subscription_ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_subscription(::protocol::DeleteSubscription* delete_subscription) {
  delete delete_subscription_;
  delete_subscription_ = delete_subscription;
  if (delete_subscription) {
    set_has_delete_subscription();
  } else {
    clear_has_delete_subscription();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.delete_subscription)
}

// optional .protocol.CreateMonitoredItem create_monitored_item = 30;
inline bool Request::has_create_monitored_item() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Request::set_has_create_monitored_item() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Request::clear_has_create_monitored_item() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Request::clear_create_monitored_item() {
  if (create_monitored_item_ != NULL) create_monitored_item_->::protocol::CreateMonitoredItem::Clear();
  clear_has_create_monitored_item();
}
inline const ::protocol::CreateMonitoredItem& Request::create_monitored_item() const {
  // @@protoc_insertion_point(field_get:protocol.Request.create_monitored_item)
  return create_monitored_item_ != NULL ? *create_monitored_item_ : *default_instance_->create_monitored_item_;
}
inline ::protocol::CreateMonitoredItem* Request::mutable_create_monitored_item() {
  set_has_create_monitored_item();
  if (create_monitored_item_ == NULL) create_monitored_item_ = new ::protocol::CreateMonitoredItem;
  // @@protoc_insertion_point(field_mutable:protocol.Request.create_monitored_item)
  return create_monitored_item_;
}
inline ::protocol::CreateMonitoredItem* Request::release_create_monitored_item() {
  clear_has_create_monitored_item();
  ::protocol::CreateMonitoredItem* temp = create_monitored_item_;
  create_monitored_item_ = NULL;
  return temp;
}
inline void Request::set_allocated_create_monitored_item(::protocol::CreateMonitoredItem* create_monitored_item) {
  delete create_monitored_item_;
  create_monitored_item_ = create_monitored_item;
  if (create_monitored_item) {
    set_has_create_monitored_item();
  } else {
    clear_has_create_monitored_item();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.create_monitored_item)
}

// optional .protocol.DeleteMonitoredItem delete_monitored_item = 31;
inline bool Request::has_delete_monitored_item() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Request::set_has_delete_monitored_item() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Request::clear_has_delete_monitored_item() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Request::clear_delete_monitored_item() {
  if (delete_monitored_item_ != NULL) delete_monitored_item_->::protocol::DeleteMonitoredItem::Clear();
  clear_has_delete_monitored_item();
}
inline const ::protocol::DeleteMonitoredItem& Request::delete_monitored_item() const {
  // @@protoc_insertion_point(field_get:protocol.Request.delete_monitored_item)
  return delete_monitored_item_ != NULL ? *delete_monitored_item_ : *default_instance_->delete_monitored_item_;
}
inline ::protocol::DeleteMonitoredItem* Request::mutable_delete_monitored_item() {
  set_has_delete_monitored_item();
  if (delete_monitored_item_ == NULL) delete_monitored_item_ = new ::protocol::DeleteMonitoredItem;
  // @@protoc_insertion_point(field_mutable:protocol.Request.delete_monitored_item)
  return delete_monitored_item_;
}
inline ::protocol::DeleteMonitoredItem* Request::release_delete_monitored_item() {
  clear_has_delete_monitored_item();
  ::protocol::DeleteMonitoredItem* temp = delete_monitored_item_;
  delete_monitored_item_ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_monitored_item(::protocol::DeleteMonitoredItem* delete_monitored_item) {
  delete delete_monitored_item_;
  delete_monitored_item_ = delete_monitored_item;
  if (delete_monitored_item) {
    set_has_delete_monitored_item();
  } else {
    clear_has_delete_monitored_item();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.delete_monitored_item)
}

// optional .protocol.HistoryRead history_read = 40;
inline bool Request::has_history_read() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Request::set_has_history_read() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Request::clear_has_history_read() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Request::clear_history_read() {
  if (history_read_ != NULL) history_read_->::protocol::HistoryRead::Clear();
  clear_has_history_read();
}
inline const ::protocol::HistoryRead& Request::history_read() const {
  // @@protoc_insertion_point(field_get:protocol.Request.history_read)
  return history_read_ != NULL ? *history_read_ : *default_instance_->history_read_;
}
inline ::protocol::HistoryRead* Request::mutable_history_read() {
  set_has_history_read();
  if (history_read_ == NULL) history_read_ = new ::protocol::HistoryRead;
  // @@protoc_insertion_point(field_mutable:protocol.Request.history_read)
  return history_read_;
}
inline ::protocol::HistoryRead* Request::release_history_read() {
  clear_has_history_read();
  ::protocol::HistoryRead* temp = history_read_;
  history_read_ = NULL;
  return temp;
}
inline void Request::set_allocated_history_read(::protocol::HistoryRead* history_read) {
  delete history_read_;
  history_read_ = history_read;
  if (history_read) {
    set_has_history_read();
  } else {
    clear_has_history_read();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.history_read)
}

// optional .protocol.CreateNode create_node = 50;
inline bool Request::has_create_node() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Request::set_has_create_node() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Request::clear_has_create_node() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Request::clear_create_node() {
  if (create_node_ != NULL) create_node_->::protocol::CreateNode::Clear();
  clear_has_create_node();
}
inline const ::protocol::CreateNode& Request::create_node() const {
  // @@protoc_insertion_point(field_get:protocol.Request.create_node)
  return create_node_ != NULL ? *create_node_ : *default_instance_->create_node_;
}
inline ::protocol::CreateNode* Request::mutable_create_node() {
  set_has_create_node();
  if (create_node_ == NULL) create_node_ = new ::protocol::CreateNode;
  // @@protoc_insertion_point(field_mutable:protocol.Request.create_node)
  return create_node_;
}
inline ::protocol::CreateNode* Request::release_create_node() {
  clear_has_create_node();
  ::protocol::CreateNode* temp = create_node_;
  create_node_ = NULL;
  return temp;
}
inline void Request::set_allocated_create_node(::protocol::CreateNode* create_node) {
  delete create_node_;
  create_node_ = create_node;
  if (create_node) {
    set_has_create_node();
  } else {
    clear_has_create_node();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.create_node)
}

// optional .protocol.DeleteNode delete_node = 51;
inline bool Request::has_delete_node() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Request::set_has_delete_node() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Request::clear_has_delete_node() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Request::clear_delete_node() {
  if (delete_node_ != NULL) delete_node_->::protocol::DeleteNode::Clear();
  clear_has_delete_node();
}
inline const ::protocol::DeleteNode& Request::delete_node() const {
  // @@protoc_insertion_point(field_get:protocol.Request.delete_node)
  return delete_node_ != NULL ? *delete_node_ : *default_instance_->delete_node_;
}
inline ::protocol::DeleteNode* Request::mutable_delete_node() {
  set_has_delete_node();
  if (delete_node_ == NULL) delete_node_ = new ::protocol::DeleteNode;
  // @@protoc_insertion_point(field_mutable:protocol.Request.delete_node)
  return delete_node_;
}
inline ::protocol::DeleteNode* Request::release_delete_node() {
  clear_has_delete_node();
  ::protocol::DeleteNode* temp = delete_node_;
  delete_node_ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_node(::protocol::DeleteNode* delete_node) {
  delete delete_node_;
  delete_node_ = delete_node;
  if (delete_node) {
    set_has_delete_node();
  } else {
    clear_has_delete_node();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.delete_node)
}

// repeated .protocol.ModifyNode modify_node = 52;
inline int Request::modify_node_size() const {
  return modify_node_.size();
}
inline void Request::clear_modify_node() {
  modify_node_.Clear();
}
inline const ::protocol::ModifyNode& Request::modify_node(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Request.modify_node)
  return modify_node_.Get(index);
}
inline ::protocol::ModifyNode* Request::mutable_modify_node(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Request.modify_node)
  return modify_node_.Mutable(index);
}
inline ::protocol::ModifyNode* Request::add_modify_node() {
  // @@protoc_insertion_point(field_add:protocol.Request.modify_node)
  return modify_node_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::ModifyNode >&
Request::modify_node() const {
  // @@protoc_insertion_point(field_list:protocol.Request.modify_node)
  return modify_node_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::ModifyNode >*
Request::mutable_modify_node() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Request.modify_node)
  return &modify_node_;
}

// optional .protocol.Reference add_reference = 54;
inline bool Request::has_add_reference() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Request::set_has_add_reference() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Request::clear_has_add_reference() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Request::clear_add_reference() {
  if (add_reference_ != NULL) add_reference_->::protocol::Reference::Clear();
  clear_has_add_reference();
}
inline const ::protocol::Reference& Request::add_reference() const {
  // @@protoc_insertion_point(field_get:protocol.Request.add_reference)
  return add_reference_ != NULL ? *add_reference_ : *default_instance_->add_reference_;
}
inline ::protocol::Reference* Request::mutable_add_reference() {
  set_has_add_reference();
  if (add_reference_ == NULL) add_reference_ = new ::protocol::Reference;
  // @@protoc_insertion_point(field_mutable:protocol.Request.add_reference)
  return add_reference_;
}
inline ::protocol::Reference* Request::release_add_reference() {
  clear_has_add_reference();
  ::protocol::Reference* temp = add_reference_;
  add_reference_ = NULL;
  return temp;
}
inline void Request::set_allocated_add_reference(::protocol::Reference* add_reference) {
  delete add_reference_;
  add_reference_ = add_reference;
  if (add_reference) {
    set_has_add_reference();
  } else {
    clear_has_add_reference();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.add_reference)
}

// optional .protocol.Reference delete_reference = 55;
inline bool Request::has_delete_reference() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Request::set_has_delete_reference() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Request::clear_has_delete_reference() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Request::clear_delete_reference() {
  if (delete_reference_ != NULL) delete_reference_->::protocol::Reference::Clear();
  clear_has_delete_reference();
}
inline const ::protocol::Reference& Request::delete_reference() const {
  // @@protoc_insertion_point(field_get:protocol.Request.delete_reference)
  return delete_reference_ != NULL ? *delete_reference_ : *default_instance_->delete_reference_;
}
inline ::protocol::Reference* Request::mutable_delete_reference() {
  set_has_delete_reference();
  if (delete_reference_ == NULL) delete_reference_ = new ::protocol::Reference;
  // @@protoc_insertion_point(field_mutable:protocol.Request.delete_reference)
  return delete_reference_;
}
inline ::protocol::Reference* Request::release_delete_reference() {
  clear_has_delete_reference();
  ::protocol::Reference* temp = delete_reference_;
  delete_reference_ = NULL;
  return temp;
}
inline void Request::set_allocated_delete_reference(::protocol::Reference* delete_reference) {
  delete delete_reference_;
  delete_reference_ = delete_reference;
  if (delete_reference) {
    set_has_delete_reference();
  } else {
    clear_has_delete_reference();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.delete_reference)
}

// optional .protocol.ChangePassword change_password = 53;
inline bool Request::has_change_password() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Request::set_has_change_password() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Request::clear_has_change_password() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Request::clear_change_password() {
  if (change_password_ != NULL) change_password_->::protocol::ChangePassword::Clear();
  clear_has_change_password();
}
inline const ::protocol::ChangePassword& Request::change_password() const {
  // @@protoc_insertion_point(field_get:protocol.Request.change_password)
  return change_password_ != NULL ? *change_password_ : *default_instance_->change_password_;
}
inline ::protocol::ChangePassword* Request::mutable_change_password() {
  set_has_change_password();
  if (change_password_ == NULL) change_password_ = new ::protocol::ChangePassword;
  // @@protoc_insertion_point(field_mutable:protocol.Request.change_password)
  return change_password_;
}
inline ::protocol::ChangePassword* Request::release_change_password() {
  clear_has_change_password();
  ::protocol::ChangePassword* temp = change_password_;
  change_password_ = NULL;
  return temp;
}
inline void Request::set_allocated_change_password(::protocol::ChangePassword* change_password) {
  delete change_password_;
  change_password_ = change_password;
  if (change_password) {
    set_has_change_password();
  } else {
    clear_has_change_password();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.change_password)
}

// optional .protocol.Browse browse = 60;
inline bool Request::has_browse() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Request::set_has_browse() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Request::clear_has_browse() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Request::clear_browse() {
  if (browse_ != NULL) browse_->::protocol::Browse::Clear();
  clear_has_browse();
}
inline const ::protocol::Browse& Request::browse() const {
  // @@protoc_insertion_point(field_get:protocol.Request.browse)
  return browse_ != NULL ? *browse_ : *default_instance_->browse_;
}
inline ::protocol::Browse* Request::mutable_browse() {
  set_has_browse();
  if (browse_ == NULL) browse_ = new ::protocol::Browse;
  // @@protoc_insertion_point(field_mutable:protocol.Request.browse)
  return browse_;
}
inline ::protocol::Browse* Request::release_browse() {
  clear_has_browse();
  ::protocol::Browse* temp = browse_;
  browse_ = NULL;
  return temp;
}
inline void Request::set_allocated_browse(::protocol::Browse* browse) {
  delete browse_;
  browse_ = browse;
  if (browse) {
    set_has_browse();
  } else {
    clear_has_browse();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Request.browse)
}

// -------------------------------------------------------------------

// Response

// required uint32 request_id = 1;
inline bool Response::has_request_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_request_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_request_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_request_id() {
  request_id_ = 0u;
  clear_has_request_id();
}
inline ::google::protobuf::uint32 Response::request_id() const {
  // @@protoc_insertion_point(field_get:protocol.Response.request_id)
  return request_id_;
}
inline void Response::set_request_id(::google::protobuf::uint32 value) {
  set_has_request_id();
  request_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Response.request_id)
}

// repeated .protocol.Status status = 2;
inline int Response::status_size() const {
  return status_.size();
}
inline void Response::clear_status() {
  status_.Clear();
}
inline const ::protocol::Status& Response::status(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Response.status)
  return status_.Get(index);
}
inline ::protocol::Status* Response::mutable_status(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Response.status)
  return status_.Mutable(index);
}
inline ::protocol::Status* Response::add_status() {
  // @@protoc_insertion_point(field_add:protocol.Response.status)
  return status_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Status >&
Response::status() const {
  // @@protoc_insertion_point(field_list:protocol.Response.status)
  return status_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Status >*
Response::mutable_status() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Response.status)
  return &status_;
}

// optional .protocol.CreateSessionResult create_session_result = 10;
inline bool Response::has_create_session_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_create_session_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_create_session_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_create_session_result() {
  if (create_session_result_ != NULL) create_session_result_->::protocol::CreateSessionResult::Clear();
  clear_has_create_session_result();
}
inline const ::protocol::CreateSessionResult& Response::create_session_result() const {
  // @@protoc_insertion_point(field_get:protocol.Response.create_session_result)
  return create_session_result_ != NULL ? *create_session_result_ : *default_instance_->create_session_result_;
}
inline ::protocol::CreateSessionResult* Response::mutable_create_session_result() {
  set_has_create_session_result();
  if (create_session_result_ == NULL) create_session_result_ = new ::protocol::CreateSessionResult;
  // @@protoc_insertion_point(field_mutable:protocol.Response.create_session_result)
  return create_session_result_;
}
inline ::protocol::CreateSessionResult* Response::release_create_session_result() {
  clear_has_create_session_result();
  ::protocol::CreateSessionResult* temp = create_session_result_;
  create_session_result_ = NULL;
  return temp;
}
inline void Response::set_allocated_create_session_result(::protocol::CreateSessionResult* create_session_result) {
  delete create_session_result_;
  create_session_result_ = create_session_result;
  if (create_session_result) {
    set_has_create_session_result();
  } else {
    clear_has_create_session_result();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Response.create_session_result)
}

// optional .protocol.ReadResponse read = 14;
inline bool Response::has_read() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_read() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_read() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_read() {
  if (read_ != NULL) read_->::protocol::ReadResponse::Clear();
  clear_has_read();
}
inline const ::protocol::ReadResponse& Response::read() const {
  // @@protoc_insertion_point(field_get:protocol.Response.read)
  return read_ != NULL ? *read_ : *default_instance_->read_;
}
inline ::protocol::ReadResponse* Response::mutable_read() {
  set_has_read();
  if (read_ == NULL) read_ = new ::protocol::ReadResponse;
  // @@protoc_insertion_point(field_mutable:protocol.Response.read)
  return read_;
}
inline ::protocol::ReadResponse* Response::release_read() {
  clear_has_read();
  ::protocol::ReadResponse* temp = read_;
  read_ = NULL;
  return temp;
}
inline void Response::set_allocated_read(::protocol::ReadResponse* read) {
  delete read_;
  read_ = read;
  if (read) {
    set_has_read();
  } else {
    clear_has_read();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Response.read)
}

// optional .protocol.CreateSubscriptionResult create_subscription_result = 20;
inline bool Response::has_create_subscription_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Response::set_has_create_subscription_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Response::clear_has_create_subscription_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Response::clear_create_subscription_result() {
  if (create_subscription_result_ != NULL) create_subscription_result_->::protocol::CreateSubscriptionResult::Clear();
  clear_has_create_subscription_result();
}
inline const ::protocol::CreateSubscriptionResult& Response::create_subscription_result() const {
  // @@protoc_insertion_point(field_get:protocol.Response.create_subscription_result)
  return create_subscription_result_ != NULL ? *create_subscription_result_ : *default_instance_->create_subscription_result_;
}
inline ::protocol::CreateSubscriptionResult* Response::mutable_create_subscription_result() {
  set_has_create_subscription_result();
  if (create_subscription_result_ == NULL) create_subscription_result_ = new ::protocol::CreateSubscriptionResult;
  // @@protoc_insertion_point(field_mutable:protocol.Response.create_subscription_result)
  return create_subscription_result_;
}
inline ::protocol::CreateSubscriptionResult* Response::release_create_subscription_result() {
  clear_has_create_subscription_result();
  ::protocol::CreateSubscriptionResult* temp = create_subscription_result_;
  create_subscription_result_ = NULL;
  return temp;
}
inline void Response::set_allocated_create_subscription_result(::protocol::CreateSubscriptionResult* create_subscription_result) {
  delete create_subscription_result_;
  create_subscription_result_ = create_subscription_result;
  if (create_subscription_result) {
    set_has_create_subscription_result();
  } else {
    clear_has_create_subscription_result();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Response.create_subscription_result)
}

// optional .protocol.CreateMonitoredItemResult create_monitored_item_result = 30;
inline bool Response::has_create_monitored_item_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Response::set_has_create_monitored_item_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Response::clear_has_create_monitored_item_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Response::clear_create_monitored_item_result() {
  if (create_monitored_item_result_ != NULL) create_monitored_item_result_->::protocol::CreateMonitoredItemResult::Clear();
  clear_has_create_monitored_item_result();
}
inline const ::protocol::CreateMonitoredItemResult& Response::create_monitored_item_result() const {
  // @@protoc_insertion_point(field_get:protocol.Response.create_monitored_item_result)
  return create_monitored_item_result_ != NULL ? *create_monitored_item_result_ : *default_instance_->create_monitored_item_result_;
}
inline ::protocol::CreateMonitoredItemResult* Response::mutable_create_monitored_item_result() {
  set_has_create_monitored_item_result();
  if (create_monitored_item_result_ == NULL) create_monitored_item_result_ = new ::protocol::CreateMonitoredItemResult;
  // @@protoc_insertion_point(field_mutable:protocol.Response.create_monitored_item_result)
  return create_monitored_item_result_;
}
inline ::protocol::CreateMonitoredItemResult* Response::release_create_monitored_item_result() {
  clear_has_create_monitored_item_result();
  ::protocol::CreateMonitoredItemResult* temp = create_monitored_item_result_;
  create_monitored_item_result_ = NULL;
  return temp;
}
inline void Response::set_allocated_create_monitored_item_result(::protocol::CreateMonitoredItemResult* create_monitored_item_result) {
  delete create_monitored_item_result_;
  create_monitored_item_result_ = create_monitored_item_result;
  if (create_monitored_item_result) {
    set_has_create_monitored_item_result();
  } else {
    clear_has_create_monitored_item_result();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Response.create_monitored_item_result)
}

// optional .protocol.HistoryReadResult history_read_result = 40;
inline bool Response::has_history_read_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Response::set_has_history_read_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Response::clear_has_history_read_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Response::clear_history_read_result() {
  if (history_read_result_ != NULL) history_read_result_->::protocol::HistoryReadResult::Clear();
  clear_has_history_read_result();
}
inline const ::protocol::HistoryReadResult& Response::history_read_result() const {
  // @@protoc_insertion_point(field_get:protocol.Response.history_read_result)
  return history_read_result_ != NULL ? *history_read_result_ : *default_instance_->history_read_result_;
}
inline ::protocol::HistoryReadResult* Response::mutable_history_read_result() {
  set_has_history_read_result();
  if (history_read_result_ == NULL) history_read_result_ = new ::protocol::HistoryReadResult;
  // @@protoc_insertion_point(field_mutable:protocol.Response.history_read_result)
  return history_read_result_;
}
inline ::protocol::HistoryReadResult* Response::release_history_read_result() {
  clear_has_history_read_result();
  ::protocol::HistoryReadResult* temp = history_read_result_;
  history_read_result_ = NULL;
  return temp;
}
inline void Response::set_allocated_history_read_result(::protocol::HistoryReadResult* history_read_result) {
  delete history_read_result_;
  history_read_result_ = history_read_result;
  if (history_read_result) {
    set_has_history_read_result();
  } else {
    clear_has_history_read_result();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Response.history_read_result)
}

// optional .protocol.CreateNodeResult create_node_result = 50;
inline bool Response::has_create_node_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Response::set_has_create_node_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Response::clear_has_create_node_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Response::clear_create_node_result() {
  if (create_node_result_ != NULL) create_node_result_->::protocol::CreateNodeResult::Clear();
  clear_has_create_node_result();
}
inline const ::protocol::CreateNodeResult& Response::create_node_result() const {
  // @@protoc_insertion_point(field_get:protocol.Response.create_node_result)
  return create_node_result_ != NULL ? *create_node_result_ : *default_instance_->create_node_result_;
}
inline ::protocol::CreateNodeResult* Response::mutable_create_node_result() {
  set_has_create_node_result();
  if (create_node_result_ == NULL) create_node_result_ = new ::protocol::CreateNodeResult;
  // @@protoc_insertion_point(field_mutable:protocol.Response.create_node_result)
  return create_node_result_;
}
inline ::protocol::CreateNodeResult* Response::release_create_node_result() {
  clear_has_create_node_result();
  ::protocol::CreateNodeResult* temp = create_node_result_;
  create_node_result_ = NULL;
  return temp;
}
inline void Response::set_allocated_create_node_result(::protocol::CreateNodeResult* create_node_result) {
  delete create_node_result_;
  create_node_result_ = create_node_result;
  if (create_node_result) {
    set_has_create_node_result();
  } else {
    clear_has_create_node_result();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Response.create_node_result)
}

// optional .protocol.DeleteNodeResult delete_node_result = 51;
inline bool Response::has_delete_node_result() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Response::set_has_delete_node_result() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Response::clear_has_delete_node_result() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Response::clear_delete_node_result() {
  if (delete_node_result_ != NULL) delete_node_result_->::protocol::DeleteNodeResult::Clear();
  clear_has_delete_node_result();
}
inline const ::protocol::DeleteNodeResult& Response::delete_node_result() const {
  // @@protoc_insertion_point(field_get:protocol.Response.delete_node_result)
  return delete_node_result_ != NULL ? *delete_node_result_ : *default_instance_->delete_node_result_;
}
inline ::protocol::DeleteNodeResult* Response::mutable_delete_node_result() {
  set_has_delete_node_result();
  if (delete_node_result_ == NULL) delete_node_result_ = new ::protocol::DeleteNodeResult;
  // @@protoc_insertion_point(field_mutable:protocol.Response.delete_node_result)
  return delete_node_result_;
}
inline ::protocol::DeleteNodeResult* Response::release_delete_node_result() {
  clear_has_delete_node_result();
  ::protocol::DeleteNodeResult* temp = delete_node_result_;
  delete_node_result_ = NULL;
  return temp;
}
inline void Response::set_allocated_delete_node_result(::protocol::DeleteNodeResult* delete_node_result) {
  delete delete_node_result_;
  delete_node_result_ = delete_node_result;
  if (delete_node_result) {
    set_has_delete_node_result();
  } else {
    clear_has_delete_node_result();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Response.delete_node_result)
}

// optional .protocol.BrowseResponse browse = 60;
inline bool Response::has_browse() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Response::set_has_browse() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Response::clear_has_browse() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Response::clear_browse() {
  if (browse_ != NULL) browse_->::protocol::BrowseResponse::Clear();
  clear_has_browse();
}
inline const ::protocol::BrowseResponse& Response::browse() const {
  // @@protoc_insertion_point(field_get:protocol.Response.browse)
  return browse_ != NULL ? *browse_ : *default_instance_->browse_;
}
inline ::protocol::BrowseResponse* Response::mutable_browse() {
  set_has_browse();
  if (browse_ == NULL) browse_ = new ::protocol::BrowseResponse;
  // @@protoc_insertion_point(field_mutable:protocol.Response.browse)
  return browse_;
}
inline ::protocol::BrowseResponse* Response::release_browse() {
  clear_has_browse();
  ::protocol::BrowseResponse* temp = browse_;
  browse_ = NULL;
  return temp;
}
inline void Response::set_allocated_browse(::protocol::BrowseResponse* browse) {
  delete browse_;
  browse_ = browse;
  if (browse) {
    set_has_browse();
  } else {
    clear_has_browse();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Response.browse)
}

// -------------------------------------------------------------------

// DataChange

// required uint32 monitored_item_id = 1;
inline bool DataChange::has_monitored_item_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataChange::set_has_monitored_item_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataChange::clear_has_monitored_item_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataChange::clear_monitored_item_id() {
  monitored_item_id_ = 0u;
  clear_has_monitored_item_id();
}
inline ::google::protobuf::uint32 DataChange::monitored_item_id() const {
  // @@protoc_insertion_point(field_get:protocol.DataChange.monitored_item_id)
  return monitored_item_id_;
}
inline void DataChange::set_monitored_item_id(::google::protobuf::uint32 value) {
  set_has_monitored_item_id();
  monitored_item_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.DataChange.monitored_item_id)
}

// required .protocol.DataValue data_value = 2;
inline bool DataChange::has_data_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataChange::set_has_data_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataChange::clear_has_data_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataChange::clear_data_value() {
  if (data_value_ != NULL) data_value_->::protocol::DataValue::Clear();
  clear_has_data_value();
}
inline const ::protocol::DataValue& DataChange::data_value() const {
  // @@protoc_insertion_point(field_get:protocol.DataChange.data_value)
  return data_value_ != NULL ? *data_value_ : *default_instance_->data_value_;
}
inline ::protocol::DataValue* DataChange::mutable_data_value() {
  set_has_data_value();
  if (data_value_ == NULL) data_value_ = new ::protocol::DataValue;
  // @@protoc_insertion_point(field_mutable:protocol.DataChange.data_value)
  return data_value_;
}
inline ::protocol::DataValue* DataChange::release_data_value() {
  clear_has_data_value();
  ::protocol::DataValue* temp = data_value_;
  data_value_ = NULL;
  return temp;
}
inline void DataChange::set_allocated_data_value(::protocol::DataValue* data_value) {
  delete data_value_;
  data_value_ = data_value;
  if (data_value) {
    set_has_data_value();
  } else {
    clear_has_data_value();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.DataChange.data_value)
}

// -------------------------------------------------------------------

// SessionDeleted

// -------------------------------------------------------------------

// Notification

// optional uint32 subscription_id = 1;
inline bool Notification::has_subscription_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Notification::set_has_subscription_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Notification::clear_has_subscription_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Notification::clear_subscription_id() {
  subscription_id_ = 0u;
  clear_has_subscription_id();
}
inline ::google::protobuf::uint32 Notification::subscription_id() const {
  // @@protoc_insertion_point(field_get:protocol.Notification.subscription_id)
  return subscription_id_;
}
inline void Notification::set_subscription_id(::google::protobuf::uint32 value) {
  set_has_subscription_id();
  subscription_id_ = value;
  // @@protoc_insertion_point(field_set:protocol.Notification.subscription_id)
}

// repeated .protocol.DataChange data_changes = 2;
inline int Notification::data_changes_size() const {
  return data_changes_.size();
}
inline void Notification::clear_data_changes() {
  data_changes_.Clear();
}
inline const ::protocol::DataChange& Notification::data_changes(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Notification.data_changes)
  return data_changes_.Get(index);
}
inline ::protocol::DataChange* Notification::mutable_data_changes(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Notification.data_changes)
  return data_changes_.Mutable(index);
}
inline ::protocol::DataChange* Notification::add_data_changes() {
  // @@protoc_insertion_point(field_add:protocol.Notification.data_changes)
  return data_changes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::DataChange >&
Notification::data_changes() const {
  // @@protoc_insertion_point(field_list:protocol.Notification.data_changes)
  return data_changes_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::DataChange >*
Notification::mutable_data_changes() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Notification.data_changes)
  return &data_changes_;
}

// repeated .protocol.NodeId added_node_id = 3;
inline int Notification::added_node_id_size() const {
  return added_node_id_.size();
}
inline void Notification::clear_added_node_id() {
  added_node_id_.Clear();
}
inline const ::protocol::NodeId& Notification::added_node_id(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Notification.added_node_id)
  return added_node_id_.Get(index);
}
inline ::protocol::NodeId* Notification::mutable_added_node_id(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Notification.added_node_id)
  return added_node_id_.Mutable(index);
}
inline ::protocol::NodeId* Notification::add_added_node_id() {
  // @@protoc_insertion_point(field_add:protocol.Notification.added_node_id)
  return added_node_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >&
Notification::added_node_id() const {
  // @@protoc_insertion_point(field_list:protocol.Notification.added_node_id)
  return added_node_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >*
Notification::mutable_added_node_id() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Notification.added_node_id)
  return &added_node_id_;
}

// repeated .protocol.NodeId deleted_node_id = 4;
inline int Notification::deleted_node_id_size() const {
  return deleted_node_id_.size();
}
inline void Notification::clear_deleted_node_id() {
  deleted_node_id_.Clear();
}
inline const ::protocol::NodeId& Notification::deleted_node_id(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Notification.deleted_node_id)
  return deleted_node_id_.Get(index);
}
inline ::protocol::NodeId* Notification::mutable_deleted_node_id(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Notification.deleted_node_id)
  return deleted_node_id_.Mutable(index);
}
inline ::protocol::NodeId* Notification::add_deleted_node_id() {
  // @@protoc_insertion_point(field_add:protocol.Notification.deleted_node_id)
  return deleted_node_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >&
Notification::deleted_node_id() const {
  // @@protoc_insertion_point(field_list:protocol.Notification.deleted_node_id)
  return deleted_node_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >*
Notification::mutable_deleted_node_id() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Notification.deleted_node_id)
  return &deleted_node_id_;
}

// repeated .protocol.NodeId semantics_changed_node_id = 5;
inline int Notification::semantics_changed_node_id_size() const {
  return semantics_changed_node_id_.size();
}
inline void Notification::clear_semantics_changed_node_id() {
  semantics_changed_node_id_.Clear();
}
inline const ::protocol::NodeId& Notification::semantics_changed_node_id(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Notification.semantics_changed_node_id)
  return semantics_changed_node_id_.Get(index);
}
inline ::protocol::NodeId* Notification::mutable_semantics_changed_node_id(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Notification.semantics_changed_node_id)
  return semantics_changed_node_id_.Mutable(index);
}
inline ::protocol::NodeId* Notification::add_semantics_changed_node_id() {
  // @@protoc_insertion_point(field_add:protocol.Notification.semantics_changed_node_id)
  return semantics_changed_node_id_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >&
Notification::semantics_changed_node_id() const {
  // @@protoc_insertion_point(field_list:protocol.Notification.semantics_changed_node_id)
  return semantics_changed_node_id_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::NodeId >*
Notification::mutable_semantics_changed_node_id() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Notification.semantics_changed_node_id)
  return &semantics_changed_node_id_;
}

// repeated .protocol.Reference added_references = 6;
inline int Notification::added_references_size() const {
  return added_references_.size();
}
inline void Notification::clear_added_references() {
  added_references_.Clear();
}
inline const ::protocol::Reference& Notification::added_references(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Notification.added_references)
  return added_references_.Get(index);
}
inline ::protocol::Reference* Notification::mutable_added_references(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Notification.added_references)
  return added_references_.Mutable(index);
}
inline ::protocol::Reference* Notification::add_added_references() {
  // @@protoc_insertion_point(field_add:protocol.Notification.added_references)
  return added_references_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Reference >&
Notification::added_references() const {
  // @@protoc_insertion_point(field_list:protocol.Notification.added_references)
  return added_references_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Reference >*
Notification::mutable_added_references() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Notification.added_references)
  return &added_references_;
}

// repeated .protocol.Reference deleted_references = 7;
inline int Notification::deleted_references_size() const {
  return deleted_references_.size();
}
inline void Notification::clear_deleted_references() {
  deleted_references_.Clear();
}
inline const ::protocol::Reference& Notification::deleted_references(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Notification.deleted_references)
  return deleted_references_.Get(index);
}
inline ::protocol::Reference* Notification::mutable_deleted_references(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Notification.deleted_references)
  return deleted_references_.Mutable(index);
}
inline ::protocol::Reference* Notification::add_deleted_references() {
  // @@protoc_insertion_point(field_add:protocol.Notification.deleted_references)
  return deleted_references_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Reference >&
Notification::deleted_references() const {
  // @@protoc_insertion_point(field_list:protocol.Notification.deleted_references)
  return deleted_references_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Reference >*
Notification::mutable_deleted_references() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Notification.deleted_references)
  return &deleted_references_;
}

// repeated .protocol.Event events = 8;
inline int Notification::events_size() const {
  return events_.size();
}
inline void Notification::clear_events() {
  events_.Clear();
}
inline const ::protocol::Event& Notification::events(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Notification.events)
  return events_.Get(index);
}
inline ::protocol::Event* Notification::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Notification.events)
  return events_.Mutable(index);
}
inline ::protocol::Event* Notification::add_events() {
  // @@protoc_insertion_point(field_add:protocol.Notification.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Event >&
Notification::events() const {
  // @@protoc_insertion_point(field_list:protocol.Notification.events)
  return events_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Event >*
Notification::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Notification.events)
  return &events_;
}

// optional .protocol.SessionDeleted session_deleted = 9;
inline bool Notification::has_session_deleted() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Notification::set_has_session_deleted() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Notification::clear_has_session_deleted() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Notification::clear_session_deleted() {
  if (session_deleted_ != NULL) session_deleted_->::protocol::SessionDeleted::Clear();
  clear_has_session_deleted();
}
inline const ::protocol::SessionDeleted& Notification::session_deleted() const {
  // @@protoc_insertion_point(field_get:protocol.Notification.session_deleted)
  return session_deleted_ != NULL ? *session_deleted_ : *default_instance_->session_deleted_;
}
inline ::protocol::SessionDeleted* Notification::mutable_session_deleted() {
  set_has_session_deleted();
  if (session_deleted_ == NULL) session_deleted_ = new ::protocol::SessionDeleted;
  // @@protoc_insertion_point(field_mutable:protocol.Notification.session_deleted)
  return session_deleted_;
}
inline ::protocol::SessionDeleted* Notification::release_session_deleted() {
  clear_has_session_deleted();
  ::protocol::SessionDeleted* temp = session_deleted_;
  session_deleted_ = NULL;
  return temp;
}
inline void Notification::set_allocated_session_deleted(::protocol::SessionDeleted* session_deleted) {
  delete session_deleted_;
  session_deleted_ = session_deleted;
  if (session_deleted) {
    set_has_session_deleted();
  } else {
    clear_has_session_deleted();
  }
  // @@protoc_insertion_point(field_set_allocated:protocol.Notification.session_deleted)
}

// -------------------------------------------------------------------

// Message

// repeated .protocol.Notification notifications = 1;
inline int Message::notifications_size() const {
  return notifications_.size();
}
inline void Message::clear_notifications() {
  notifications_.Clear();
}
inline const ::protocol::Notification& Message::notifications(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Message.notifications)
  return notifications_.Get(index);
}
inline ::protocol::Notification* Message::mutable_notifications(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Message.notifications)
  return notifications_.Mutable(index);
}
inline ::protocol::Notification* Message::add_notifications() {
  // @@protoc_insertion_point(field_add:protocol.Message.notifications)
  return notifications_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Notification >&
Message::notifications() const {
  // @@protoc_insertion_point(field_list:protocol.Message.notifications)
  return notifications_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Notification >*
Message::mutable_notifications() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Message.notifications)
  return &notifications_;
}

// repeated .protocol.Request requests = 2;
inline int Message::requests_size() const {
  return requests_.size();
}
inline void Message::clear_requests() {
  requests_.Clear();
}
inline const ::protocol::Request& Message::requests(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Message.requests)
  return requests_.Get(index);
}
inline ::protocol::Request* Message::mutable_requests(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Message.requests)
  return requests_.Mutable(index);
}
inline ::protocol::Request* Message::add_requests() {
  // @@protoc_insertion_point(field_add:protocol.Message.requests)
  return requests_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Request >&
Message::requests() const {
  // @@protoc_insertion_point(field_list:protocol.Message.requests)
  return requests_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Request >*
Message::mutable_requests() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Message.requests)
  return &requests_;
}

// repeated .protocol.Response responses = 3;
inline int Message::responses_size() const {
  return responses_.size();
}
inline void Message::clear_responses() {
  responses_.Clear();
}
inline const ::protocol::Response& Message::responses(int index) const {
  // @@protoc_insertion_point(field_get:protocol.Message.responses)
  return responses_.Get(index);
}
inline ::protocol::Response* Message::mutable_responses(int index) {
  // @@protoc_insertion_point(field_mutable:protocol.Message.responses)
  return responses_.Mutable(index);
}
inline ::protocol::Response* Message::add_responses() {
  // @@protoc_insertion_point(field_add:protocol.Message.responses)
  return responses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocol::Response >&
Message::responses() const {
  // @@protoc_insertion_point(field_list:protocol.Message.responses)
  return responses_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocol::Response >*
Message::mutable_responses() {
  // @@protoc_insertion_point(field_mutable_list:protocol.Message.responses)
  return &responses_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protocol::Qualifier_Severity> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Qualifier_Severity>() {
  return ::protocol::Qualifier_Severity_descriptor();
}
template <> struct is_proto_enum< ::protocol::Qualifier_SubCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Qualifier_SubCode>() {
  return ::protocol::Qualifier_SubCode_descriptor();
}
template <> struct is_proto_enum< ::protocol::Qualifier_Limit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::Qualifier_Limit>() {
  return ::protocol::Qualifier_Limit_descriptor();
}
template <> struct is_proto_enum< ::protocol::ProtocolVersionMajor> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ProtocolVersionMajor>() {
  return ::protocol::ProtocolVersionMajor_descriptor();
}
template <> struct is_proto_enum< ::protocol::ProtocolVersionMinor> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ProtocolVersionMinor>() {
  return ::protocol::ProtocolVersionMinor_descriptor();
}
template <> struct is_proto_enum< ::protocol::ConstantNodeId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::ConstantNodeId>() {
  return ::protocol::ConstantNodeId_descriptor();
}
template <> struct is_proto_enum< ::protocol::AttributeId> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::AttributeId>() {
  return ::protocol::AttributeId_descriptor();
}
template <> struct is_proto_enum< ::protocol::NodeClass> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::NodeClass>() {
  return ::protocol::NodeClass_descriptor();
}
template <> struct is_proto_enum< ::protocol::BrowseDirection> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protocol::BrowseDirection>() {
  return ::protocol::BrowseDirection_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_scada_2eproto__INCLUDED
